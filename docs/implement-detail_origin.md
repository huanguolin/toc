# ç±»å‹ä½“æ“ä¹‹å®ç°ä¸€ä¸ªç±»Cé£æ ¼è¯­è¨€çš„è§£é‡Šå™¨

- [ç±»å‹ä½“æ“ä¹‹å®ç°ä¸€ä¸ªç±»Cé£æ ¼è¯­è¨€çš„è§£é‡Šå™¨](#ç±»å‹ä½“æ“ä¹‹å®ç°ä¸€ä¸ªç±»cé£æ ¼è¯­è¨€çš„è§£é‡Šå™¨)
  - [1. ts çš„ç±»å‹ç³»ç»Ÿæ˜¯æ€æ ·çš„å‡½æ•°å¼è¯­è¨€ï¼Ÿ](#1-ts-çš„ç±»å‹ç³»ç»Ÿæ˜¯æ€æ ·çš„å‡½æ•°å¼è¯­è¨€)
    - [1.1 ç±»å‹ä¸å€¼](#11-ç±»å‹ä¸å€¼)
    - [1.2 å˜é‡](#12-å˜é‡)
    - [1.3 æ¡ä»¶](#13-æ¡ä»¶)
      - [1.3.1 å¯èµ‹å€¼æ€§](#131-å¯èµ‹å€¼æ€§)
      - [1.3.2 æ¨¡å¼åŒ¹é…](#132-æ¨¡å¼åŒ¹é…)
      - [1.3.3 å±€éƒ¨å¸¸é‡](#133-å±€éƒ¨å¸¸é‡)
    - [1.4 å‡½æ•°](#14-å‡½æ•°)
      - [1.4.1 æ³›å‹](#141-æ³›å‹)
      - [1.4.2 ç±»å‹å·¥å…·â€”â€”å‡½æ•°](#142-ç±»å‹å·¥å…·å‡½æ•°)
      - [1.4.3 é€’å½’](#143-é€’å½’)
      - [1.4.4 å¾ªç¯ <=> é€’å½’](#144-å¾ªç¯--é€’å½’)
      - [1.4.5 å°¾é€’å½’](#145-å°¾é€’å½’)
      - [1.4.6 First-Class-Function](#146-first-class-function)
  - [2. å¦‚ä½•å®ç° Toc è§£é‡Šå™¨ï¼Ÿ](#2-å¦‚ä½•å®ç°-toc-è§£é‡Šå™¨)
    - [2.1 å››åˆ™è¿ç®—ä»¥åŠå¤§å°æ¯”è¾ƒ](#21-å››åˆ™è¿ç®—ä»¥åŠå¤§å°æ¯”è¾ƒ)
    - [2.2 è§£é‡Šå™¨](#22-è§£é‡Šå™¨)
      - [2.2.1 Toc çš„è¯­æ³•](#221-toc-çš„è¯­æ³•)
      - [2.2.2 è¯æ³•åˆ†æ](#222-è¯æ³•åˆ†æ)
        - [2.2.2.1 åˆ†è¯ï¼ˆtsç‰ˆï¼‰](#2221-åˆ†è¯tsç‰ˆ)
        - [2.2.2.2 åˆ†è¯ï¼ˆtypeç‰ˆï¼‰](#2222-åˆ†è¯typeç‰ˆ)
      - [2.2.3 è¯­æ³•åˆ†æ](#223-è¯­æ³•åˆ†æ)
        - [2.2.3.1 é€’å½’ä¸‹é™](#2231-é€’å½’ä¸‹é™)
        - [2.2.3.2 å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æ(tsç‰ˆæœ¬)](#2232-å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†ætsç‰ˆæœ¬)
        - [2.2.3.3 å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æ(typeç‰ˆæœ¬)](#2233-å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†ætypeç‰ˆæœ¬)
      - [2.2.4 æ‰§è¡Œ](#224-æ‰§è¡Œ)
        - [2.2.4.1 è®¿é—®è€…æ¨¡å¼ä¸ts-Interpreter](#2241-è®¿é—®è€…æ¨¡å¼ä¸ts-interpreter)
        - [2.2.4.2 type-Interpreter](#2242-type-interpreter)
      - [2.2.5 è¯­å¥](#225-è¯­å¥)
        - [2.2.5.1 è¡¨è¾¾å¼è¯­å¥](#2251-è¡¨è¾¾å¼è¯­å¥)
        - [2.2.5.2 var è¯­å¥](#2252-var-è¯­å¥)
        - [2.2.5.3 ç¯å¢ƒ](#2253-ç¯å¢ƒ)
        - [2.2.5.4 å˜é‡è¡¨è¾¾å¼å’Œèµ‹å€¼è¡¨è¾¾å¼](#2254-å˜é‡è¡¨è¾¾å¼å’Œèµ‹å€¼è¡¨è¾¾å¼)
        - [2.2.5.5 ä½œç”¨åŸŸ](#2255-ä½œç”¨åŸŸ)
        - [2.2.5.6 block è¯­å¥](#2256-block-è¯­å¥)
        - [2.2.5.7 if è¯­å¥](#2257-if-è¯­å¥)
        - [2.2.5.8 for è¯­å¥](#2258-for-è¯­å¥)
      - [2.2.6 å‡½æ•°](#226-å‡½æ•°)
        - [2.2.6.1 å‡½æ•°è¯­å¥](#2261-å‡½æ•°è¯­å¥)
        - [2.2.6.2 call è¡¨è¾¾å¼](#2262-call-è¡¨è¾¾å¼)
      - [2.2.7 æœªå°½äº‹å®œ](#227-æœªå°½äº‹å®œ)
  - [3. æ€»ç»“](#3-æ€»ç»“)
  - [4. å‚è€ƒ](#4-å‚è€ƒ)

TypeScript æ˜¯ JavaScript çš„è¶…é›†ï¼Œä¸»è¦ç»™ JavaScript æ·»åŠ äº†é™æ€ç±»å‹æ£€æŸ¥ï¼Œå¹¶ä¸”ä¸ä¹‹å®Œå…¨å…¼å®¹ã€‚åœ¨è¿è¡Œæ—¶ï¼Œç±»å‹å®Œå…¨æ“¦é™¤ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼ŒTypeScript ç±»å‹ç³»ç»Ÿæå…¶å¼ºå¤§ï¼Œè¿™æ ·æ‰èƒ½åœ¨ç»´æŒ JavaScript åŠ¨æ€æ€§ï¼Œåšå¿«é€Ÿå¼€å‘çš„åŒæ—¶ï¼Œåšåˆ°æ›´å¤šçš„ç±»å‹æç¤ºä¸é”™è¯¯æ£€æŸ¥ã€‚

> ä¸‹é¢ä¸ºäº†ç®€å•ï¼Œå°†ç”¨ tsã€js è¿™æ ·çš„ç®€ç§°ä»£æ›¿ TypeScriptã€JavaScriptã€‚

åŠ¨æ€æ€§ä¸é™æ€æ£€æŸ¥ä¼¼ä¹æ˜¯å†²çªçš„ï¼Ÿä½†æ˜¯ ts å›¢é˜Ÿå’Œç¤¾åŒºç»™å‡ºäº†è¦å…¼é¡¾ä¸¤è€…çš„ä¸€æ¡è·¯ã€‚å°±æ˜¯åœ¨ ts ç¼–è¯‘å™¨æ— æ³•åšå‡ºæ¨æ–­æ—¶ï¼Œè®©å¼€å‘è€…å‘Šè¯‰ ts å¦‚ä½•æ¨æ–­ã€‚è€Œå‘Šè¯‰ ts çš„è¿™æ®µç±»å‹æè¿°ï¼ˆç®€å•è¯´ï¼Œå°±æ˜¯éšç€è¾“å…¥ç±»å‹ä¸åŒï¼Œè¾“å‡ºç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆï¼‰ï¼Œå’Œå¯¹åº” js ä»£ç é€»è¾‘æ˜¯ä¸€è‡´çš„ï¼ˆå› ä¸ºåªè€ƒè™‘ç±»å‹ï¼Œå¾€å¾€ä¼šç®€å•ä¸€äº›ï¼‰ã€‚æ‰€ä»¥ ts çš„ç±»å‹ç³»ç»Ÿï¼Œè¦å¼ºå¤§åˆ°[å›¾çµå®Œå¤‡](https://github.com/microsoft/TypeScript/issues/14833)æ‰èƒ½èƒœä»»ã€‚

ts çš„ç±»å‹ç³»ç»Ÿæ˜¯ä¸€é—¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€‚ç±»å‹ä½“æ“è¯´çš„å°±æ˜¯åˆ©ç”¨è¿™é—¨ç¼–ç¨‹è¯­è¨€ç©èŠ±æ ·ã€‚æˆ‘ä»¬ä»Šå¤©è¦ç©çš„ï¼Œå°±æ˜¯ç”¨å®ƒå®ç°å¦ä¸€é—¨è¯­è¨€ï¼ˆè¿™é—¨è¯­è¨€æˆ‘å–åå«[Toc](https://github.com/huanguolin/Toc)ï¼‰çš„è§£é‡Šå™¨(å¦‚æœè¦ä½“éªŒè¿™ä¸ªè§£é‡Šå™¨è¯·åˆ°[Toc](https://github.com/huanguolin/Toc)ä»“åº“, å¾ˆå®¹æ˜“æ‰¾åˆ°å…¥å£ğŸ˜Š)ã€‚`Toc` è¯­è¨€æ˜¯ `C` é£æ ¼è¯­æ³•ï¼Œæ¥è¿‘ `js`ã€‚åŠ¨æ€ç±»å‹ï¼ŒåŸºç¡€ç±»å‹æœ‰æ•°å­—ã€å¸ƒå°”ã€å­—ç¬¦ä¸²å’Œ `null`ï¼Œæ”¯æŒå˜é‡ï¼Œè¡¨è¾¾å¼ï¼Œå—è¯­å¥ï¼Œ`if-else` æ¡ä»¶è¯­å¥ï¼Œ`for` å¾ªç¯è¯­å¥ï¼Œå‡½æ•°ã€‚ä¸”å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œå¯ä»¥ä¼ å…¥ä¼ å‡ºï¼Œæ”¯æŒé—­åŒ…ã€‚æ›´è¯¦ç»†çš„è¯­æ³•ï¼Œå¯ä»¥å‚è§ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md)ã€‚

å¦‚æœä½ å¯¹ ts çš„ç±»å‹ç³»ç»Ÿè¿˜ä¸æ˜¯å¾ˆäº†è§£ï¼Œæ²¡å…³ç³»ã€‚ğŸ˜Šæˆ‘ä»¬ä¸æ˜¯é©¬ä¸Šå°±åŠ¨æ‰‹å®ç°å®ƒï¼Œå…ˆåšç‚¹çƒ­èº«è¿åŠ¨â€”â€”æ¥çœ‹çœ‹ ts çš„ç±»å‹ç³»ç»Ÿæä¾›äº†ä»€ä¹ˆï¼Œæœ‰ä»€ä¹ˆé™åˆ¶ã€‚æ‰€ä»¥ï¼Œæœ¬æ–‡åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š
1. ts çš„ç±»å‹ç³»ç»Ÿæ˜¯æ€æ ·çš„å‡½æ•°å¼è¯­è¨€ï¼Ÿ
2. å¦‚ä½•å®ç° Toc è§£é‡Šå™¨ï¼Ÿ

å¦‚æœç¬¬ä¸€éƒ¨åˆ†å¯¹ä½ æ²¡æœ‰ä»€ä¹ˆæ–°å¥‡çš„ï¼Œå¯ä»¥ç›´æ¥è·³åˆ°ç¬¬äºŒéƒ¨åˆ†ã€‚

## 1. ts çš„ç±»å‹ç³»ç»Ÿæ˜¯æ€æ ·çš„å‡½æ•°å¼è¯­è¨€ï¼Ÿ
è¯´åˆ°ç¼–ç¨‹è¯­è¨€ï¼Œæˆ‘ä»¬ä¼šæƒ³åˆ°è‡³å°‘è¦åŒ…å«å˜é‡ã€æ¡ä»¶ã€å¾ªç¯ã€å‡½æ•°è¿™äº›ç‰¹æ€§ï¼Œå¦åˆ™æ²¡æ³•ç”¨ï¼ˆå½“ç„¶æˆ‘è¯´çš„æ˜¯æ­£å¸¸çš„ç¼–ç¨‹è¯­è¨€ï¼Œå¯ä¸æ˜¯åƒ [Ook!](https://code.tutsplus.com/articles/10-most-bizarre-programming-languages-ever-created--net-2412) è¿™ç§ï¼‰ã€‚ä¸è¿‡åœ¨æˆ‘è°ˆå˜é‡ã€æ¡ä»¶ã€å¾ªç¯ã€å‡½æ•°è¿™äº›ä¹‹å‰ï¼Œæˆ‘è¦è¯´ç‚¹æ›´åŸºç¡€çš„ä¸œè¥¿ã€‚

### 1.1 ç±»å‹ä¸å€¼

ç±»å‹æ˜¯æè¿°å€¼çš„é›†åˆï¼Œæ¯”å¦‚ `number` ä»£è¡¨äº†æ‰€æœ‰æ•°å­—ã€‚`1` æ˜¯ `number` çš„ä¸€ä¸ªå€¼ã€‚ä½† `1` ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®ƒæè¿°çš„é›†åˆä¸­åªæœ‰ä¸€ä¸ªå€¼ç½¢äº†ã€‚ts å…è®¸æˆ‘ä»¬åšè¿™ç§ç²¾ç¡®ç±»å‹æè¿°ã€‚æ‰€ä»¥å®ƒè¿˜æä¾›äº†è”åˆç±»å‹ï¼ˆ[union](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)ï¼‰, å…ƒç»„([tuple](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types))ç­‰ã€‚
```ts
type A = 1;

// union
type B = 'red' | 'green' | 'blue';

// tuple
type C = [B, number]; // ['red' | 'green' | 'blue', number]
```
> [auto_gen()]()

å½“ç„¶å¥¹ä¹Ÿæä¾›äº†å…¨é›†å’Œç©ºé›†ï¼š`any` å’Œ `never`ã€‚
ä¸‹é¢æˆ‘ä»¬å›å½’å˜é‡ã€æ¡ä»¶ã€å¾ªç¯ã€å‡½æ•°å§ã€‚


### 1.2 å˜é‡
é¢ï¼Œå®é™…ä¸Š ts çš„ç±»å‹ç³»ç»Ÿå¹¶æ²¡æœ‰æä¾›å˜é‡ï¼Œå®ƒåªæä¾›äº†å¸¸é‡ï¼Œè¿™å¾ˆå‡½æ•°å¼ã€‚ä¸è¿‡è¿™å°±å¤Ÿç”¨äº†ï¼Œå¦‚æœä½ ç†Ÿæ‚‰å…¶ä»–å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œä½ å°±çŸ¥é“äº†ã€‚
```ts
type A = 2;
type B = string | A; // string | 2
```
> [auto_gen()]()

è¿™å°±æ˜¯å…¨éƒ¨å—ï¼Ÿé¢ï¼Œè¿™æ˜¯å…¨å±€å¸¸é‡ã€‚å…¶å®è¿˜æœ‰ä¸€ç§æ˜¯å±€éƒ¨å¸¸é‡ï¼Œè¿™ä¸ªç­‰è¯´æ¡ä»¶çš„æ—¶å€™è®²ã€‚å¦å¤–æˆ‘è¯´è¿‡æœ‰å‡½æ•°ï¼Œå‡½æ•°çš„å…¥å‚ä¹Ÿæ˜¯ä¸€ç§å¸¸é‡å•ŠğŸ˜¼ã€‚

### 1.3 æ¡ä»¶
```ts
type A = 2;
type B = A extends number ? true : false; // true
```
> [auto_gen()]()

æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼Ÿ

`A extends B ? C : D` è¿™ä¸ªå½¢å¼ï¼Œè¡¨è¾¾çš„æ˜¯ `A` å¯ä»¥èµ‹å€¼ç»™ `B`ï¼Œåˆ™ç»“æœæ˜¯ `C`ï¼Œå¦åˆ™ä¸º `D`ã€‚å¯èµ‹å€¼åœ¨ ts ä¸­æ˜¯ä¸ªå…³é”®çš„ä¸œè¥¿ï¼Œæˆ‘ä¸‹é¢å°±æ¥è®²è®²ã€‚

#### 1.3.1 å¯èµ‹å€¼æ€§
ts é‡‡ç”¨çš„æ˜¯ç»“æ„å‹ç±»å‹ç³»ç»Ÿï¼ˆ[Structural Type System](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#structural-type-system), ä¹Ÿè¢«ç§°ä¹‹ä¸º[é¸­å­ç±»å‹](https://en.wikipedia.org/wiki/Duck_typing)ï¼‰ã€‚å°±æ˜¯è¯´ï¼Œts è®¤ä¸ºä½ æ˜¯ä»€ä¹ˆç±»å‹æ˜¯çœ‹ä½ æœ‰ä»€ä¹ˆä¸œè¥¿ï¼Œæˆ–è€…è¯´ç»“æ„æ˜¯ä¸æ˜¯ç¬¦åˆæŸä¸ªç±»å‹å®šä¹‰çš„ç»“æ„ã€‚åªè¦ç¬¦åˆæŸä¸ªç±»å‹å®šä¹‰çš„ç»“æ„å°±å¯ä»¥ï¼Œä¸å¿…åƒ `java` æˆ–è€… `c#` é‚£æ ·ï¼Œå¿…é¡»è¦åœ¨å®šä¹‰æ—¶è¯´æ˜¯æŸä¸ªç±»å‹æ‰å¯ä»¥ã€‚
```ts
type Cat = {
    eat: (food: string) => void;
};
type HuntDog = {
    eat: (food: string) => void;
    hunt: () => string;
};

type IsCat = HuntDog extends Cat ? true : false; // true

let cat: Cat = {
    eat: (food: string) => console.log(`eat ${food}`)
};
let hDog = {
    eat: (food: string) => console.log(`eat ${food}`),
    hunt: () => 'animal',
};

let hDog2: HuntDog = hDog; // ok
cat = hDog; // ok
hDog2 = cat; // error: Property 'hunt' is missing in type 'Cat' but required in type 'HuntDog'
```
> [auto_gen()]()

å›åˆ° `A extends B ? C : D` ï¼Œåªè¦ A ç±»å‹ç¬¦åˆ B ç±»å‹çš„å®šä¹‰ï¼Œæˆ–è€…è¯´ A ç±»å‹æ˜¯ B ç±»å‹çš„å­é›†ï¼ˆå½“ç„¶ï¼Œä»»ä½•é›†åˆéƒ½æ˜¯è‡ªèº«çš„å­é›†ï¼‰ï¼Œæ¡ä»¶å°±æˆç«‹ï¼Œå¦åˆ™ä¸ºä¸æˆç«‹ã€‚è¿™ç§å½¢å¼ä¸‹ï¼Œè¿˜æœ‰ä¸€ç§å¯çœ‹ä½œæ˜¯æ¨¡å¼åŒ¹é…çš„è¯­æ³•ã€‚

#### 1.3.2 æ¨¡å¼åŒ¹é…
```ts
type A = Promise<string>;
type B = A extends Promise<infer C> ? C : never; // string

type T = [string, 1, null, A];
type R = T extends [string, ...infer Rest] ? Rest : never; // [1, null, A]
```
> [auto_gen()]()

è¿™ç§è¯­æ³•å¯ä»¥è¯†åˆ« `extends` å·¦è¾¹æ˜¯ä¸æ˜¯ç¬¦åˆå³è¾¹çš„ç±»å‹ç»“æ„ï¼Œå¦‚æœç¬¦åˆï¼Œå¯ä»¥æ¨æ–­å‡ºå…¶ä¸­çš„æŸä¸ªéƒ¨åˆ†ã€‚

#### 1.3.3 å±€éƒ¨å¸¸é‡
ä¸Šé¢ä¾‹å­ç§çš„ `C` å’Œ `Rest` å°±æ˜¯å±€éƒ¨å¸¸é‡ã€‚åˆ©ç”¨è¿™ä¸ªæˆ‘å¯ä»¥éšæ—¶åœ¨å±€éƒ¨æ¢ä¸ªå˜é‡åå­—ï¼š
```ts
type T = [string, 1, null, undefined];
type R = T extends [string, ...infer Rest]
    ? Rest extends [1, ...infer Rest]
        ? Rest extends [null, infer Rest] // æ—§åå­—ï¼Œåœ¨æ–°çš„ä½œç”¨åŸŸä¸‹ä»£è¡¨çš„å€¼å˜åŒ–äº†
            ? Rest extends infer Last // æ¢åå­—ï¼Œå¥½æ— èŠğŸ¥±ï¼Œåˆ«æ‹…å¿ƒï¼Œåé¢ä¼šç”¨ä¸Šçš„
                ? Last
                : never
            : never
        : never
    : never;
// undefined
```
> [auto_gen()]()

åœ¨ [4.7](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#extends-constraints-on-infer-type-variables), [4.8](https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#infer-types-template-strings) ä¸¤ä¸ªç‰ˆæœ¬è¿˜å¯¹è¿™ä¸ªæ¡ä»¶è¡¨è¾¾å¼æœ‰æ‰©å±•å’Œä¼˜åŒ–ï¼Œåç»­ä¼šè®²åˆ°ã€‚


### 1.4 å‡½æ•°
ä¸è¯¥è®²å¾ªç¯äº†å—ï¼Ÿé¢...å…¶å® ts ç±»å‹ç³»ç»Ÿä¸­æ²¡æœ‰å¾ªç¯ğŸ˜“ã€‚ä¸è¿‡åˆ«æ€¥ï¼Œæœ‰æ›¿ä»£å“ã€‚æˆ‘æƒ³ä½ èƒ½çŒœåˆ°çš„â€¦â€¦
æ²¡é”™ï¼Œå°±æ˜¯é€’å½’ï¼æ‰€ä»¥è¦å…ˆçœ‹ä¸‹å‡½æ•°ã€‚

#### 1.4.1 æ³›å‹
åœ¨çœ‹å‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å…ˆçœ‹æ³›å‹ã€‚ts ç±»å‹ç³»ç»Ÿå¹¶æ²¡æœ‰æ˜è¯´â€œæˆ‘ä»¬æä¾›äº†å¯ä¾›ç±»å‹ç¼–ç¨‹çš„å‡½æ•°â€ã€‚ä½†å®ƒçš„æ³›å‹å´æä¾›äº†ä¸€æ ·çš„èƒ½åŠ›ã€‚
```ts
function flatten<T>(arr: (T | T[])[]): T[] {
    let result: T[] = [];
    for (let x of arr) {
        if (Array.isArray(x)) {
            result = result.concat(flatten(x));
        } else {
            result.push(x);
        }
    }
    return result;
}

console.log(flatten([1, 2, [3, 4], 5, [[6, 7], 8]])); // [1, 2, 3, 4, 5, 6, 7, 8]
console.log(flatten(['abc', ['123', ['456', '789']], 'def'])); // ["abc", "123", "456", "789", "def"]
```
> [auto_gen()]()

è¿™æ˜¯å¸¸è§„ç”¨æ³•â€”â€”æ³›å‹è®©æˆ‘ä»¬æ›´å®¹æ˜“å¤ç”¨ç®—æ³•(ä¸”ç±»å‹å®‰å…¨)ã€‚ts ç±»å‹ç³»ç»Ÿä¸­ï¼Œå€ŸåŠ©æ³›å‹å¯ä»¥å¤ç”¨ç›¸åŒå½¢å¼çš„ç±»å‹å£°æ˜ã€‚å¦‚ `Promise<T>`ã€‚è¿˜å¯ç”¨ä½œå·¥å…·ç±»å‹ï¼Œå®˜æ–¹å°±æä¾›äº†å¤šä¸ª [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html), å¦‚: `Required<Type>, Pick<Type, Keys>`ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå·±å®ç°ä¸€äº›å·¥å…·ç±»å‹ï¼Œç”¨èµ·æ¥å°±åƒå‡½æ•°ã€‚

#### 1.4.2 ç±»å‹å·¥å…·â€”â€”å‡½æ•°
```ts
type PromiseValue<T> = T extends PromiseLike<infer V> ? V : never;

type TestPV1 = PromiseValue<Promise<string>>; // string
type TestPV2 = PromiseValue<Promise<'r' | 'g' | 'b'>>; // 'r' | 'g' | 'b'


type First<T extends unknown[], Fallback = unknown> = T extends [infer F, ...infer rest] ? F : Fallback;

type TestF1 = First<['r' | 'g' | 'b', number]>; // 'r' | 'g' | 'b'
type TestF2 = First<[string[]]>; // string[]
type TestF3 = First<[]>; // unknown
type TestF4 = First<[], any>; // any
```
> [auto_gen()]()

è¿™é‡Œæ³›å‹å‚æ•°å°±æ˜¯å‡½æ•°å‚æ•°ï¼Œé€šè¿‡ `extends` å¯ä»¥çº¦æŸç±»å‹ï¼Œæ³›å‹å‚æ•°ä¹Ÿæ”¯æŒé»˜è®¤å€¼ã€‚

å¦‚æœç»™ `PromiseValue<T>` ä¼ å…¥ `Promise<Promise<number>>` çš„è¯ï¼Œç»“æœæ˜¯ `Promise<number>`ã€‚å‡å¦‚è¿™ä¸ªæ—¶å€™ï¼Œè¿˜æ˜¯æƒ³è·å¾—æœ€é‡Œé¢çš„ç±»å‹ï¼Œå³ `number`ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿé‚£å°±è¯¥é€’å½’ç™»åœºäº†ã€‚

#### 1.4.3 é€’å½’
```ts
type PromiseValue<T> = T extends PromiseLike<infer V> ? V : never;

type TestPV1 = PromiseValue<Promise<Promise<number>>>; // Promise<number>

type PromiseValueDeep<T> = T extends PromiseLike<infer V> ? PromiseValueDeep<V> : T;

type TestPVD1 = PromiseValueDeep<Promise<Promise<number>>>; // number
```
> [auto_gen()]()

æœ‰äº†é€’å½’ï¼Œå°±å¯ä»¥è®²å¾ªç¯äº†ğŸ˜„ï¼

#### 1.4.4 å¾ªç¯ <=> é€’å½’
å‰é¢è¯´äº†ï¼Œts ç±»å‹ç³»ç»Ÿä¸­å¹¶æ²¡æœ‰æä¾›å¾ªç¯çš„åŸè¯­ã€‚ä½†æ˜¯é€’å½’å¯ä»¥æ›¿ä»£å¾ªç¯ï¼Œå®ƒä»¬æ˜¯ç­‰ä»·çš„ã€‚ä½ æ²¡å¬é”™ï¼Œé€’å½’å’Œå¾ªç¯ç­‰ä»·ï¼äºŒè€…å¯ä»¥ç›¸äº’è½¬æ¢ã€‚æˆ‘ä»¬ä¸¾ä¸ªä¾‹å­ï¼Œå°†æ•°å­—æ•°ç»„æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼š
```ts
function join(arr: number[]): string {
    let result = '';
    for (let x of arr) {
        result += x;
    }
    return result;
}
console.log(join([1, 2, 3])); // '123'

type Join<Arr extends number[], Result extends string = ''> =
    Arr extends [infer F, ...infer Rest]
        ? F extends number
            ? Rest extends number[]
                ? Join<Rest, `${Result}${F}`>
                : never
            : never
        : Result;
type test = Join<[1, 2, 3]>; // '123'
```
> [auto_gen()]()

ä¸Šé¢çš„ç”¨å¾ªç¯å®ç°çš„ä»£ç ï¼Œç”¨é€’å½’ä¹ŸåŒæ ·èƒ½åšåˆ°ã€‚åªä¸è¿‡æˆ‘ä»¬çš„ç±»å‹ç‰ˆ `Join` çœ‹èµ·æ¥æœ‰ç‚¹å•°å—¦ï¼ˆå¤šäº†ä¸¤ä¸ªåˆ¤æ–­ğŸ˜”ï¼‰ã€‚ä¸è¿‡ï¼Œåœ¨ [4.7](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#extends-constraints-on-infer-type-variables) ç‰ˆæœ¬æœ‰æ”¹è¿›è¿™é‡Œçš„è¯­æ³•ã€‚æ‰€ä»¥å¯ä»¥æ”¹æˆï¼š
```ts
function join(arr: number[]): string {
    let result = '';
    for (let x of arr) {
        result += x;
    }
    return result;
}
console.log(join([1, 2, 3])); // '123'

type Join<Arr extends number[], Result extends string = ''> =
    Arr extends [infer F extends number, ...infer Rest extends number[]]
        ? Join<Rest, `${Result}${F}`>
        : Result;
type test = Join<[1, 2, 3]>; // '123'
```
> [auto_gen()]()

ç°åœ¨çœ‹èµ·æ¥æ˜¯ä¸æ˜¯ç®€æ´äº†è®¸å¤šï¼ŒäºŒè€…è½¬æ¢çš„ä»£ç å¯¹æ¯”ä¹Ÿæ›´å®¹æ˜“çœ‹æ¸…äº†ã€‚ä»å¾ªç¯æ˜ å°„ä¸ºé€’å½’ï¼š
> å¾ªç¯ç»“æŸæ¡ä»¶ -> é€’å½’ç»“æŸæ¡ä»¶
> å¾ªç¯ç´¯è®¡å˜é‡ result -> é€’å½’å‡½æ•°"ç´¯è®¡"å‚æ•° Result
> å¾ªç¯ç§»åŠ¨å˜é‡ x -> é€’å½’å‡½æ•°"ç§»åŠ¨"å‚æ•° Arr

åœ¨çº¯å‡½æ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ˜¯æ²¡æœ‰å¾ªç¯çš„ï¼Œåªèƒ½ç”¨é€’å½’æ¥ä»£æ›¿ã€‚ä½†æ˜¯å¤§å®¶éƒ½çŸ¥é“ï¼Œé€’å½’ä¼šå¯¼è‡´å‡½æ•°è°ƒç”¨æ ˆå¿«é€ŸåŠ æ·±ã€‚åˆ°è¾¾ä¸€å®šæ·±åº¦ï¼Œå°±ä¼šçˆ†æ ˆã€‚é‚£è¿™ä¸ªé—®é¢˜æ€ä¹ˆè§£å†³å‘¢ï¼Ÿ

ç­”æ¡ˆæ˜¯å°¾é€’å½’ä¼˜åŒ–ã€‚

> ä¸ºä»€ä¹ˆçº¯å‡½æ•°ç¼–ç¨‹è¯­è¨€ä¸­æ²¡æœ‰å¾ªç¯ï¼Ÿéš¾é“æ˜¯å› ä¸ºæœ‰é€’å½’å¯ç”¨ï¼Œå°±ä¸å¿…å¤šæä¸€å¥—ä¸œè¥¿ï¼Ÿ
> é¢ï¼Œæˆ–è€…æˆ‘é—®ä½ ï¼Œæ²¡æœ‰å˜é‡å¦‚ä½•å®ç°å¾ªç¯ï¼Ÿ
> â€¦â€¦
> ğŸ˜„æˆ‘æƒ³ä½ çŸ¥é“äº†ï¼Œåšä¸åˆ°ï¼
> æ²¡æœ‰å˜é‡æ— æ³•ä¿å­˜çŠ¶æ€ï¼Œæ‰€ä»¥å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€é€‰æ‹©ç”¨å‡½æ•°å‚æ•°æ¥â€œä¿å­˜â€ã€‚

#### 1.4.5 å°¾é€’å½’
æˆ‘ä»¬ä¸Šé¢å†™çš„é€’å½’éƒ½æ˜¯å°¾é€’å½’ï¼Œç°åœ¨æˆ‘ä»¬æ¥ä¸€ä¸ªä¸æ˜¯çš„ï¼š
```ts
type TreeNode = {
    value: number;
    left: TreeNode | null;
    right: TreeNode | null;
};

type Tree<V extends number, L extends TreeNode | null = null, R extends TreeNode | null = null> = {
    value: V;
    left: L;
    right: R;
};

type PreOrderTraverse<T extends TreeNode> =
    T extends Tree<infer V, infer L, infer R>
        ? [V, ...PreOrderTraverse<L>, ...PreOrderTraverse<R>]
        : [];

//         1
//       /   \
//      2     6
//     / \      \
//    3   5      7
//     \        /  \
//      4       8   9
type tree = Tree<1,
    Tree<2,
        Tree<3,
            null,
            Tree<4>>,
        Tree<5>>,
    Tree<6,
        null,
        Tree<7,
            Tree<8>,
            Tree<9>>>>;

type test = PreOrderTraverse<tree>; // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
> [auto_gen()]()

å°¾é€’å½’ä¸éå°¾é€’å½’çš„åŒºåˆ«å°±æ˜¯å‡½æ•°è¿”å›æ—¶ï¼Œæ˜¯ç›´æ¥ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿˜æ˜¯å‡½æ•°è°ƒç”¨å¤¹åœ¨ä¸€ä¸ªè¡¨è¾¾å¼ä¸­ã€‚
[å°¾é€’å½’ä¼˜åŒ–](https://stackoverflow.com/questions/310974/what-is-tail-call-optimization)ï¼Œæ˜¯é€šè¿‡å¤ç”¨ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ ˆæ¥é¿å…çˆ†æ ˆã€‚åœ¨ ts ä¸­ä¹Ÿæ˜¯æœ‰è¿™æ ·çš„ä¼˜åŒ–ã€‚ä½ è·³åˆ°ä¸Šé¢çš„åœ¨çº¿ä½“éªŒç¤ºä¾‹ï¼Œä¼šå‘ç° `? [V, ...PreOrderTraverse<L>, ...PreOrderTraverse<R>]` è¿™ä¸€è¡Œï¼Œts æœ‰ error æç¤ºï¼š

`Type instantiation is excessively deep and possibly infinite.(2589)`

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå°±å¦‚æç¤ºæ‰€è¯´ï¼šç±»å‹å®ä¾‹åŒ–çš„æ·±åº¦è¿‡å¤§ï¼Œå¯èƒ½æ˜¯æ— é™çš„ã€‚ts éœ€è¦åœ¨æˆ‘ä»¬å†™ä»£ç æ—¶ï¼Œè¿›è¡Œå®æ—¶ä»£ç æç¤ºå’Œçº é”™ã€‚è¿‡äºå¤æ‚çš„ç±»å‹åŠ¿å¿…ä¼šæ‹–ç´¯è¿™ä¸ªè¿‡ç¨‹ï¼Œé€ æˆä¸å¯æ¥å—çš„ç”¨æˆ·ä½“éªŒä¸‹é™ã€‚æ‰€ä»¥ ts ä¸ä»…è¦é¿å…çˆ†æ ˆï¼Œè€Œä¸”è¿˜è¦è®¡ç®—é€Ÿåº¦ã€‚æ—©æœŸç‰ˆæœ¬å¯¹é€’å½’æ·±åº¦çš„é™åˆ¶æ˜¯ 50 å±‚ã€‚åœ¨ [4.5](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#tailrec-conditional) æ—¶åšäº†ä¼˜åŒ–ï¼Œæé«˜åˆ° 100 å±‚ï¼Œå¦‚æœæ˜¯å°¾é€’å½’åˆ™æé«˜åˆ° 1000 å±‚ã€‚åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°æ¯”ä»¥å‰æ›´å¤æ‚çš„ä½“æ“ã€‚

ä½†æ˜¯ï¼Œæœ€ç»ˆï¼Œè¿™é‡Œçš„é™åˆ¶æ¯”å…¶ä»–ç¼–ç¨‹è¯­è¨€æ›´è‹›åˆ»ï¼Œä¸å…è®¸æˆ‘ä»¬åšé•¿æ—¶è¿ç®—ã€‚æ„å‘³ç€ï¼ŒåŸºäºå®ƒå®ç°çš„å¾ªç¯åªèƒ½å¾ªç¯å¾ˆæœ‰é™çš„æ¬¡æ•°ğŸ˜“ï¼Œå‡½æ•°è°ƒç”¨ä¹Ÿå¿…ç„¶ä¸èƒ½å¤ªæ·±â€¦â€¦


#### 1.4.6 First-Class-Function
åœ¨çœ‹åˆ°ä¸Šé¢çš„é™åˆ¶åï¼Œæˆ–è®¸ä½ æ„Ÿåˆ°æœ‰ç‚¹é—æ†¾ï¼ˆä¸€åˆ‡éƒ½æ˜¯æƒè¡¡ï¼Œæ²¡æœ‰ä»€ä¹ˆæ˜¯å®Œç¾çš„ï¼‰ã€‚ä½†æ˜¯ä¸å¾—ä¸å‘Šè¯‰ä½ ï¼Œè¿˜æœ‰å¦å¤–ä¸€ä»¶ä¸å¹¸çš„äº‹ã€‚å®ƒæ²¡æœ‰å‡½æ•°å¼è¯­è¨€çš„æ ‡å¿—æ€§èƒ½åŠ›â€”â€” [First-Class-Function](https://en.wikipedia.org/wiki/First-class_function)ã€‚å³æ²¡æœ‰åŠæ³•ä¼ å…¥/ä¼ å‡ºå‡½æ•°ï¼Œæ— æ³•å®ç°é«˜é˜¶å‡½æ•°ã€‚ä¸è¿‡å¥½åœ¨ï¼Œæ²¡æœ‰è¿™ä¸ªèƒ½åŠ›ï¼Œå¹¶ä¸ä¼šå½±å“è¡¨è¾¾èƒ½åŠ›ã€‚åªæ˜¯éº»çƒ¦å¾ˆå¤šğŸ˜“ã€‚

ç®€å•æ¥è¯´ï¼Œä½¿ç”¨ `Function(argumentsironment1) => return + environment2` çš„æ–¹å¼ï¼Œå¯ä»¥è¡¨è¾¾å¯¹ç­‰çš„ä¸œè¥¿ã€‚

ä»¥ä¸Šå°±æ˜¯è¿™é—¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€çš„ä»‹ç»ã€‚ä¼‘æ¯ä¸€ä¸‹ã€‚æˆ‘ä»¬å°±è¦å¼€å§‹ç¼–å†™è§£é‡Šå™¨äº†ğŸ˜„ã€‚


## 2. å¦‚ä½•å®ç° Toc è§£é‡Šå™¨ï¼Ÿ

åœ¨å®ç°è§£é‡Šå™¨ä¹‹å‰ï¼Œæˆ‘é‡åˆ°çš„ç¬¬ä¸€ä¸ªéº»çƒ¦äº‹æƒ…æ˜¯ï¼Œå¦‚ä½•å®ç°å››åˆ™è¿ç®—ï¼Ÿæ¯•ç«Ÿè¿™äº›åŸºæœ¬è¿ç®—æ˜¯ä¸€å®šè¦æ”¯æŒçš„å•Šï¼å°±ä»…ä»…æ”¯æŒæ­£æ•´æ•°è¿ç®—ï¼Œå°±è¦ä¸€äº›æŠ€å·§å‘¢ï¼æ˜¯çš„ï¼Œæˆ‘ä»¬å°±åªæ”¯æŒæ­£æ•´æ•°è¿ç®—ã€‚

### 2.1 å››åˆ™è¿ç®—ä»¥åŠå¤§å°æ¯”è¾ƒ
å¦‚æœç¬¬ä¸€æ¬¡é¢å¯¹è¿™ä¸ªé—®é¢˜ï¼Œè¿˜çœŸæ˜¯æœ‰ç‚¹æ‘¸ä¸ç€å¤´è„‘ã€‚å°±æœ€ç®€å•ï¼ŒåŠ æ³•æ€ä¹ˆå®ç°å•Šï¼Ÿæˆ‘ä¼¼ä¹æ˜¯ Google åï¼Œæ‰¾åˆ°ç­”æ¡ˆçš„ã€‚
```ts
type A = [1, 2, 3];
type L1 = A['length']; // 3
type L2 = ['a', number]['length']; // 2
type L3 = []['length']; // 0
```
> [auto_gen()]()

ä»¥ä¸Šçš„ä¾‹å­ä»£ç ï¼Œæ˜¯å¦è®©ä½ æ‰¾åˆ°äº†å®ç°åŠ æ³•çš„çµæ„Ÿï¼Ÿæˆ–è®¸ä½ å·²ç»æƒ³åˆ°äº†â€¦â€¦æ²¡é”™ï¼ŒåŠ æ³•å°±æ˜¯å‡†å¤‡ä¸¤ä¸ªæŒ‡å®šé•¿åº¦æ•°ç»„ï¼Œç„¶ååˆå¹¶ï¼Œç„¶åå–åˆå¹¶æ•°ç»„çš„é•¿åº¦ã€‚

é‚£ä¹ˆæˆ‘éœ€è¦ä¸€ä¸ªç”ŸæˆæŒ‡å®šé•¿åº¦æ•°ç»„çš„å‡½æ•°:
```ts
type InitArray<L extends number, A extends any[] = []> =
    A['length'] extends L
        ? A
        : InitArray<L, [...A, any]>;
type test_init_array_1 = InitArray<0>; // []
type test_init_array_2 = InitArray<3>; // [any, any, any]
```
> [auto_gen(InitArray)]()

ç°åœ¨å¯ä»¥å®ç°åŠ æ³•äº†:
```ts
type Add<N1 extends number, N2 extends number> = [...InitArray<N1>, ...InitArray<N2>]['length'];
type test_add_1 = Add<1, 3>; // 4
type test_add_2 = Add<0, 10>; // 10
type test_add_3 = Add<19, 13>; // 32
```
> [auto_gen(Add)](InitArray)

å®ç°äº†åŠ æ³•ï¼Œå‡æ³•ä¹Ÿæ˜¯æ‰‹åˆ°æ“’æ¥ã€‚è¿˜æ˜¯ä¸¤ä¸ªæ•°ç»„ï¼Œè¢«å‡æ•°æ•°ç»„æ¯æ¬¡å‡å°‘ä¸€ä¸ªå…ƒç´ ï¼Œå‡å°‘å‡æ•°æ¬¡ï¼Œåœ¨å–è¢«å‡æ•°æ•°ç»„é•¿åº¦å³å¯ã€‚

```ts
type Sub<
    N1 extends number,
    N2 extends number,
    A extends any[] = InitArray<N1>, // è¢«å‡æ•°æ•°ç»„
    C extends any[] = [], // è®¡æ•°æ•°ç»„
> = N2 extends C['length']
    ? A['length']
    : A extends [infer F, ...infer Rest extends any[]]
        ? Sub<N1, N2, Rest, [...C, any]>
        : 0; // è¢«å‡æ•°å°äºå‡æ•°
type test_sub_1 = Sub<10, 3>; // 7
type test_sub_2 = Sub<18, 9>; // 9
type test_sub_3 = Sub<9, 13>; // 0
```
> [auto_gen(Sub)](InitArray)

ğŸ˜„ï¼Œniceï¼
æœ‰äº†åŠ æ³•ï¼Œä¹˜æ³•ä¹Ÿå¾ˆå®¹æ˜“ï¼Œ`A * B` ç­‰åŒäº `B` ä¸ª `A` ç›¸åŠ ï¼Œä¸è¿‡è¦æ³¨æ„ 0 ä¹˜ä»¥ä»»ä½•æ•° éƒ½å¾— 0:

```ts
type Mul<
    N1 extends number,
    N2 extends number,
    A extends number = N1, // ç»“æœ
    C extends number = 1, // è®¡æ•°æ•°å­—
> = N1 extends 0
    ? 0
    : N2 extends 0
        ? 0
        : C extends N2
            ? A
            : Mul<N1, N2, Add<A, N1>, Add<C, 1>>;
type test_mul_1 = Mul<11, 3>; // 33
type test_mul_2 = Mul<8, 9>; // 72
type test_mul_3 = Mul<9, 0>; // 0
```
> [auto_gen(Mul_beta)](Add)

ä¸è¿‡ `Add<A, N1>` è¿™é‡Œæç¤º:

`Type 'Add<A, N1>' does not satisfy the constraint 'number'.(2344)`ã€‚

æ„æ€æ˜¯å®ƒçš„ç»“æœä¸æ˜¯æ°¸è¿œéƒ½èƒ½å¾—åˆ° `number`, æ‰€ä»¥ä¸å®‰å…¨ã€‚è¿™é‡Œåº”è¯¥æ˜¯å¯èƒ½è¾“å‡º `never` æˆ–è€… `any` çš„æƒ…å†µï¼Œè¿™å¾ˆæç«¯ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨ä¸€ä¸ªç±»ä¼¼æ–­è¨€çš„å·¥å…·å‡½æ•°æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼š

```ts
type Safe<T, Type, Default extends Type = Type> = T extends Type ? T : Default;
```
> [auto_gen(Safe)]()

`Safe<T, U, D>` ä¸»è¦ç”¨æ¥è¿›ä¸€æ­¥ç¡®è®¤ `T` æ˜¯ `U` ç±»å‹, å¦åˆ™è¯·å– `D` ç±»å‹ã€‚æœ‰äº†å®ƒï¼Œæˆ‘ä»¬åœ¨ä¿®æ”¹ä¸€ä¸‹ï¼š

```ts
type Mul<
    N1 extends number,
    N2 extends number,
    A extends number = N1, // ç»“æœ
    C extends number = 1, // è®¡æ•°æ•°å­—
> = N1 extends 0
    ? 0
    : N2 extends 0
        ? 0
        : C extends N2
            ? A
            : Mul<N1, N2, Safe<Add<A, N1>, number>, Safe<Add<C, 1>, number>>; // ã€ˆ--- Safe here
type test_mul_1 = Mul<11, 3>; // 33
type test_mul_2 = Mul<8, 9>; // 72
type test_mul_3 = Mul<9, 0>; // 0
```
> [auto_gen(Mul)](Add,Safe)

æ¥ä¸‹æ¥è¯¥é™¤æ³•äº†ã€‚æ€è·¯æ˜¯ç±»ä¼¼çš„ï¼Œç›´æ¥çœ‹ä»£ç ï¼š
```ts
type Div<
    N1 extends number,
    N2 extends number,
    A extends number = N1, // ç»“æœ
    C extends number = 0, // è®¡æ•°æ•°å­—
> = N1 extends 0
    ? 0
    : N2 extends 0
        ? never // é™¤æ•°ä¸èƒ½ä¸º 0
        : A extends 0
            ? C
            : Div<N1, N2, Sub<A, N2>, Safe<Add<C, 1>, number>>;
type test_div_1 = Div<12, 3>; // 4
type test_div_2 = Div<8, 9>; // 0
type test_div_3 = Div<100, 33>; // 3
```
> [auto_gen(Div_beta)](Sub,Safe,Add)

è·‘èµ·æ¥çœ‹çœ‹ï¼Œå•Šï¼`test2`, `test3` çš„å€¼æ€ä¹ˆæ˜¯ `1` å’Œ `4`ï¼Œ ä¸æ˜¯æˆ‘ä»¬æœŸå¾…çš„ `0` å’Œ `3`ã€‚åŸå› åœ¨äºåƒï¼Œ`8 / 9` è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬æ— æ³•åˆ†è¾¨å‡º `8 - 9` å’Œ `8 - 8` è¿™æ ·çš„åŒºåˆ«ã€‚å¦‚æœèƒ½åˆ†è¾¨å¤§å°å°±å¥½åŠäº†ã€‚

æ€ä¹ˆæ¯”è¾ƒå¤§å°å‘¢ï¼Ÿè¯´å®è¯ï¼Œæˆ‘ç¬¬ä¸€æ¬¡æƒ³è¿™ä¸ªé—®é¢˜ï¼ŒçœŸçš„æ˜¯ä¸€ç‚¹æ€è·¯ä¹Ÿæ²¡æœ‰ğŸ˜“ã€‚è¿˜å¥½æˆ‘ Google åˆ°äº†ã€‚æ–¹æ³•å°±æ˜¯åŒæ—¶å¯¹ä¸¤ä¸ªæ•°å­—å‡ 1ï¼Œè°å…ˆåˆ° 0ï¼Œè°å°±å°ã€‚ç›¸ç­‰çš„æƒ…å†µæ¯”è¾ƒå¥½å¤„ç†ã€‚ä¸‹é¢æ¥çœ‹å®ç°ï¼š

```ts
type Eq<A, B> =
    A extends B
    ? (B extends A ? true : false)
    : false;

type Lt<A extends number, B extends number> =
    Eq<A, B> extends true
        ? false
        : A extends 0
            ? true
            : B extends 0
                ? false
                : Lt<Sub<A, 1>, Sub<B, 1>>;
type test_lt_1 = Lt<1, 3>;
type test_lt_2 = Lt<3, 2>;
type test_lt_3 = Lt<3, 3>;
```
> [auto_gen(Lt)](Sub)

æ¥ä¸‹æ¥æˆ‘ä»¬æŠŠé™¤æ³•æå¯¹ï¼š

```ts
type Div<
    N1 extends number,
    N2 extends number,
    A extends number = N1, // ç»“æœ
    C extends number = 0, // è®¡æ•°æ•°å­—
> = N1 extends 0
    ? 0
    : N2 extends 0
        ? never // é™¤æ•°ä¸èƒ½ä¸º 0
        : Lt<A, N2> extends true
            ? C
            : Div<N1, N2, Sub<A, N2>, Safe<Add<C, 1>, number>>;
type test_div_1 = Div<12, 3>; // 4
type test_div_2 = Div<8, 9>; // 0
type test_div_3 = Div<100, 33>; // 3
```
> [auto_gen(Div)](Sub, Safe, Add, Lt)

Good job! ä¸€åˆ‡éƒ½å¦‚æœŸè€Œè‡³ï¼

ä¸Šé¢å®ç°äº† `Lt`ï¼Œ é‚£ä¹ˆå…¶ä»–å‡ ä¸ªæ¯”è¾ƒå‡½æ•°å°±ä¸éš¾äº†ï¼Œè¿™éƒ¨åˆ†å°±ç•™ç€è¯»è€…ä½ å»è¯•è¯•å§ã€‚

åœ¨è¿™ä¸€å°èŠ‚ç»“æŸï¼Œæˆ‘æƒ³è¯´ï¼Œå®ç°å››åˆ™è¿ç®—å’Œå¤§å°æ¯”è¾ƒå…¶å®è¿˜æœ‰å¦å¤–ä¸€ç§æ€è·¯ã€‚æˆ‘æœ€æ—©è€ƒè™‘åŠ æ³•çš„å®ç°å°±åªæƒ³åˆ°è¿™ä¸ªæ€è·¯â€”â€”ç”¨å­—ç¬¦ä¸²æ¥å®ç°ã€‚

å¯¹äºåŠ æ³•ï¼Œå°±æ˜¯æŒ‰ä½(æ˜¯ä¸ªä½ï¼Œåä½è¿™æ ·å“¦)æŸ¥è¡¨åŠ ï¼Œå«è¿›ä½å¤„ç†ã€‚ç»“æœè¿˜æ˜¯ä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²ã€‚

å¯¹äºå°äºæ¯”è¾ƒï¼Œå…ˆæ¯”è¾ƒå­—ç¬¦ä¸²é•¿åº¦ï¼Œè°çŸ­è°å°ï¼Œé•¿åº¦ä¸€æ ·ï¼ŒæŒ‰ä½æŸ¥è¡¨æ¯”è¾ƒï¼Œä»é«˜ä½å¼€å§‹ã€‚

å¯¹äºå¤§å°æ¯”è¾ƒè¿™ä¸ªæ–¹æ¡ˆï¼Œæ˜¯å®Œå…¨OKçš„ã€‚ä½†æ˜¯åŠ æ³•ï¼Œä»æ•°å­—è½¬å­—ç¬¦ä¸²å¾ˆå®¹æ˜“ã€‚ä½†æ˜¯åè¿‡æ¥ï¼Œå´ä»€ä¹ˆå¥½æ²¡åŠæ³•ã€‚ä¸è¿‡ï¼Œ[4.8](https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#infer-types-template-strings) ç‰ˆæœ¬è¿™ä¸ªé—®é¢˜è§£å†³äº†ã€‚
```ts
type SN = '123' extends `${infer N extends number}` ? N : never; // 123
```
æ‰€ä»¥ä¸€åˆ‡éƒ½å¾ˆå®Œç¾ï¼ä½ å¯èƒ½ä¼šé—®ï¼Œè¿™ä¸ªæ–¹æ¡ˆå¬èµ·æ¥å¾ˆå¤æ‚ï¼Œå’Œå‰é¢ç”¨æ•°ç»„å®ç°çš„æ¯”èµ·æ¥ï¼Œä¼¼ä¹æ²¡æœ‰ä»»ä½•ä¼˜åŠ¿ã€‚å¤æ‚æ˜¯çœŸçš„å¤æ‚ï¼Œä½†ä¼˜åŠ¿æ˜¯æœ‰çš„ã€‚æˆ‘ä»¬å‰é¢è¯´è¿‡ï¼Œts ç±»å‹è¿ç®—æ˜¯æœ‰é€’å½’æ·±åº¦é™åˆ¶çš„ã€‚æ•°ç»„çš„å®ç°å¯ä»¥å¾ˆå¿«è§¦ç¢°åˆ°é™åˆ¶ï¼Œè€Œå­—ç¬¦ä¸²çš„æ–¹æ¡ˆåœ¨å¾ˆå¤§çš„æ•°ä¸Šéƒ½æ²¡æœ‰è§¦åˆ°é™åˆ¶ã€‚
```ts
type test_add_1 = Add<999, 999>; // 1998
type test_add_2 = Add<999, 1000>; // Type instantiation is excessively deep and possibly infinite.(2589)
```
> [auto_gen()](Add)

å¦‚æœä½ æƒ³ä½“éªŒå­—ç¬¦ä¸²ç‰ˆæœ¬ï¼Œå¯ä»¥ç›´æ¥å»ä»“åº“ [Toc](https://github.com/huanguolin/Toc) ç‚¹å‡»å‰å¾€è§£é‡Šå™¨ã€‚è¾“å…¥ `type Result = Toc<'99999 + 99999;'>` æ¥ä½“éªŒã€‚å› ä¸º `Toc` åº•å±‚å°±æ˜¯ç”¨çš„å­—ç¬¦ä¸²ç‰ˆæœ¬ã€‚ä»£ç åœ¨[è¿™é‡Œ](https://github.com/huanguolin/Toc/tree/master/type-Toc/utils/math/fast)ã€‚

å¥½äº†ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬åº”è¯¥å‡†å¤‡å¥½å¼€å§‹å®ç°è§£é‡Šå™¨äº†ã€‚

### 2.2 è§£é‡Šå™¨

æˆ‘ä»¬çš„è§£é‡Šå™¨ä¸»è¦åˆ†ä¸‰æ­¥ï¼šè¯æ³•åˆ†æï¼Œè¯­æ³•åˆ†æï¼Œæ‰§è¡Œã€‚

![interpreter-3-steps](https://github.com/huanguolin/toc/blob/master/docs/imgs/interpreter-3-steps.png)

å¦å¤–ä¸ºäº†å¯¹æ¯”ï¼Œä¹Ÿä¸ºäº†ç…§é¡¾æƒ³æˆ‘ä¸€æ ·éç§‘ç­å‡ºèº«çš„äººï¼Œæˆ‘ä¼šè®²ä¸¤ä¸ªç‰ˆæœ¬çš„å®ç°ï¼ˆä¸ªäººæ„Ÿè§‰ç›´æ¥çœ‹ä¸€é—¨ç†Ÿæ‚‰çš„è¯­è¨€æ¥å®ç°è§£é‡Šå™¨ä¼šæ›´å¥½æ¥å—ä¸€ç‚¹ï¼‰ï¼š
* ç”¨ tsï¼ˆä½ å¯ä»¥ç†è§£ä¸ºç”¨ jsï¼‰å®ç°çš„ï¼Œåœ¨ [ts-Toc](https://github.com/huanguolin/Toc/tree/master/ts-Toc) ä¸‹ã€‚
* ç”¨ ts ç±»å‹ç³»ç»Ÿå®ç°çš„ï¼Œåœ¨ [type-Toc](https://github.com/huanguolin/Toc/tree/master/type-Toc) ä¸‹ã€‚

æˆ‘åœ¨è®²ä¸€ä¸ªç‰¹æ€§æ—¶ï¼Œä¼šå…ˆè®² ts ç‰ˆï¼Œç„¶åè¯´ type ç‰ˆã€‚åœ¨å®ç° ts ç‰ˆæœ¬æ—¶ï¼Œä¸ä¼šè€ƒè™‘è¦â€œç¿»è¯‘â€ä¸º type ç‰ˆï¼Œè€Œæ”¾å¼ƒå¯¹å®ƒæ¥è¯´æœ€è‡ªç„¶çš„æ–¹æ³•ã€‚è¿™æ ·åšçš„ç›®çš„ï¼Œä¸€æ˜¯ä¸ºäº†å¥½ç†è§£ï¼ˆç‰¹åˆ«æ˜¯éç§‘ç­çš„åŒå­¦ï¼‰ï¼›äºŒæ˜¯ä¸ºäº†å¯¹æ¯”ï¼Œèƒ½çœ‹åˆ°åœ¨è¯­è¨€â€œè´«ç˜ â€çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¦‚ä½•â€œç»•â€ã€‚

#### 2.2.1 Toc çš„è¯­æ³•
åœ¨å®ç°ä¸€é—¨è¯­è¨€æ—¶ï¼Œå…ˆè¦çŸ¥é“å®ƒçš„è¯­æ³•ï¼Œ`Toc` çš„è¯­æ³•å®šä¹‰å·²ç»å®šä¹‰åœ¨ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md)ã€‚ä½†æ˜¯å¯¹äºæ²¡æœ‰ç¼–è¯‘åŸç†åŸºç¡€çš„äººæ¥è¯´ï¼Œå¯¹é‚£äº›ç¬¦å·è¦è¡¨è¾¾ä»€ä¹ˆè¿˜æ˜¯å¾ˆå›°æƒ‘çš„ï¼ˆæ¯”å¦‚æˆ‘ğŸ¤¦ï¼‰ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä»¥è¡¨è¾¾å¼ä¸ºå¼•å­ï¼Œåšä¸€ä¸ªç®€è¦çš„è§£é‡Šã€‚

æˆ‘ä»¬å¸¸å¸¸çœ‹åˆ°ä¸‹é¢è¿™æ ·çš„è¡¨è¾¾å¼ï¼Œè¿™äº›éƒ½æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰ï¼Œä¸”è¢« `Toc` æ”¯æŒçš„ï¼š
```js
// Toc æ”¯æŒçš„è¡¨è¾¾å¼
1 + (10 - 2 * 3) < 4 == false
```

`Toc` çš„è¡¨è¾¾å¼åŒ…å«çš„è¦ç´ ï¼š
* å­—é¢é‡ï¼Œå³åŸºç¡€æ•°æ®ç±»å‹ï¼šæ•°å­—ï¼Œå¸ƒå°”ï¼Œå­—ç¬¦ä¸²å’Œ `null`
* ä¸€å…ƒè¡¨è¾¾å¼ï¼Œå³åªæœ‰ä¸€ä¸ªæ“ä½œæ•°çš„è¡¨è¾¾å¼ï¼šä»…é€»è¾‘å ï¼
* äºŒå…ƒè¡¨è¾¾å¼ï¼Œå³æœ‰ä¸¤ä¸ªæ“ä½œæ•°çš„è¡¨è¾¾å¼ï¼šæœ‰æ•°å­¦è¡¨è¾¾å¼(+, -, *, /, %)å’Œé€»è¾‘è¡¨è¾¾å¼(&&, ||, ==, !=, >, >=, <, <=)
* æ‹¬å·è¡¨è¾¾å¼ï¼Œå³ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥çš„è¡¨è¾¾å¼ï¼š()

å¦‚æœæˆ‘ä»¬ç”¨è¯­æ³•å®šä¹‰æ¥ç¿»è¯‘ä¸Šé¢è¿™æ®µè¯ï¼š
```sh
expression     â†’ literal
               | unary
               | binary
               | grouping ;

literal        â†’ NUMBER | STRING | "true" | "false" | "null" ;
unary          â†’ "!" expression ;
binary         â†’ expression operator expression ;
operator       â†’ "&&" | "||" | "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+" | "-" | "*" | "/" | "%" ;
grouping       â†’ "(" expression ")" ;
```
å…¶ä¸­ï¼Œ`NUMBER` å’Œ `STRING` ä»£è¡¨ä»»ä½•æ•°å­—ã€å­—ç¬¦ä¸²ã€‚å¸¦å¼•å·çš„éƒ½æ˜¯ç»ˆæ­¢ç¬¦ã€‚å½“ç„¶ `literal` ä¹Ÿéƒ½æ˜¯ç»ˆæ­¢ç¬¦ã€‚ç»ˆæ­¢ç¬¦æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå°±æ˜¯å®ƒæ— æ³•å†ç»§ç»­å±•å¼€æˆæ›´åŸºæœ¬çš„å•ä½ã€‚ä¸Šé¢çš„ `expression`, `unary`, `binary`, `grouping` éƒ½æ˜¯å¯ä»¥ç»§ç»­å±•å¼€çš„ï¼Œæ‰€ä»¥æ˜¯éç»ˆæ­¢ç¬¦ã€‚å¦‚ä½•å±•å¼€ï¼Œå°±ä»£è¡¨äº†ç›¸å°çš„è¯­æ³•è§„åˆ™ã€‚

ä½ å¯èƒ½æ³¨æ„åˆ°ï¼Œä¸Šé¢çš„è¿™æ®µè¯­æ³•æè¿°å’Œ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md) ä¸­çš„å¹¶ä¸å®Œå…¨ä¸€æ ·ã€‚ä¸è¿‡è¿™ä»…ä»…æ˜¯å½¢å¼çš„ä¸åŒï¼Œè¯­æ³•å«ä¹‰æ˜¯ä¸€æ ·çš„ã€‚åªæ˜¯è¿™é‡Œä¸ºäº†ç®€å•æ²¡æœ‰åŒ…å«ä¼˜å…ˆçº§çš„ä¿¡æ¯ã€‚ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md) ä¸­çš„æè¿°ä¸ä»…åŒ…å«äº†ä¼˜å…ˆçº§ä¿¡æ¯ï¼Œè€Œä¸”ä¸ºäº†æ˜“äºå®ç°ï¼Œåšäº†ä¸€äº›è°ƒæ•´ã€‚ä¸è¿‡ï¼Œæ‰€è¦è¡¨è¾¾è¯­æ³•è§„åˆ™æ˜¯ä¸€è‡´çš„ã€‚å…³äºä¼˜å…ˆçº§çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬åœ¨è¯­æ³•åˆ†æçš„éƒ¨åˆ†ä¼šé‡ç‚¹è®²è§£ã€‚åŸºäºç°åœ¨è®¤è¯†ï¼Œæˆ‘æƒ³ä½ å·²ç»èƒ½çœ‹æ‡‚ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md) ä¸­ç»å¤§æ•°çš„è§„åˆ™äº†ã€‚å¯ä»¥å¼€å§‹è¯æ³•åˆ†æå•¦ğŸ˜ºã€‚

#### 2.2.2 è¯æ³•åˆ†æ
è¯æ³•åˆ†æçš„å…³é”®æ˜¯åˆ†è¯â€”â€”å°±æ˜¯æŠŠè¾“å…¥çš„ä»£ç æ‹†æˆä¸€ä¸ªä¸€ä¸ªæœ‰åºçš„è¯­æ³•ç¬¦å·ï¼ˆtokenï¼‰ã€‚è¿™é‡Œè¦å¤„ç†çš„ä¸»è¦é—®é¢˜æ˜¯ï¼Œåœ¨å“ªé‡Œæ‹†å¼€ï¼Ÿå“ªäº›å­—ç¬¦è¦è¿åˆ°ä¸€èµ·ä½œä¸ºä¸€ä¸ªè¯­æ³•ç¬¦å·ï¼Ÿæˆ‘ä»¬å–ä¸Šé¢è¡¨è¾¾å¼çš„ä¾‹å­ï¼š
```js
1 + (10 - 2 * 3) < 4 == false
// æ‹†åˆ†æˆï¼š
['1', '+', '(', '10', '-', '2', '*', '3', ')', '<', '4', '==', 'false']
```
åšè¿™ä¸ªæ‹†åˆ†å¯ä»¥ç”¨æ­£åˆ™ï¼Œä¹Ÿå¯ä»¥é€å­—ç¬¦æ¥åˆ†æã€‚è¿™é‡Œæˆ‘é€‰å–åè€…ï¼Œä¸ä»…æ˜¯å› ä¸º ts ç±»å‹ç³»ç»Ÿä¸­æ²¡æœ‰æ­£åˆ™ï¼Œé€å­—ç¬¦åˆ†æ‹†çš„ä»£ç ä¹Ÿå¾ˆè‡ªç„¶ç®€å•ï¼Œä¸”é«˜æ•ˆï¼

##### 2.2.2.1 åˆ†è¯ï¼ˆtsç‰ˆï¼‰

ä¸Šé¢çš„å­—ç¬¦ä¸²æ•°ç»„ä¸€èˆ¬ä¸å»ºè®®ç›´æ¥ä½œä¸º `Tokens` è¾“å‡ºç»™è¯­æ³•åˆ†æå™¨ã€‚å¸¸è§„çš„åšæ³•æ˜¯å®šä¹‰ä¸€ä¸ª `Token` çš„ç»“æ„æ¥æè¿°ã€‚ä¸ä»…ä»…åŒ…å«åŸå§‹çš„è¯ç´ (`lexeme`)ï¼Œè¿˜åº”è¯¥åŒ…å«å¿…è¦ä¿¡æ¯ï¼Œæ¯”å¦‚ï¼šæ˜¯å­—ç¬¦ä¸²è¿˜æ˜¯æ•°å­—ï¼Œæ˜¯æ“ä½œç¬¦è¿˜æ˜¯å…³é”®å­—ç­‰ã€‚æ­£å¸¸è¿˜è¦åŒ…å« `debug` éœ€è¦çš„è¡Œå·ã€åˆ—å·ç­‰ä¿¡æ¯ã€‚æˆ‘ä»¬è¿™é‡Œä¸ºäº†ç®€å•ï¼ŒåªåŒ…å«æœ€ä¸»è¦çš„ä¿¡æ¯ï¼Œæ²¡æœ‰ `debug` ä¿¡æ¯ã€‚

è¦å®šä¹‰ `Token`ï¼Œå…ˆè¦å®šä¹‰å®ƒæœ‰å¤šå°‘ç§ç±»ï¼š
```ts
type TokenType =
    | 'identifier'
    | 'string'
    | 'number'
    | 'fun'
    | 'var'
    | 'for'
    | 'if'
    | 'else'
    | 'true'
    | 'false'
    | 'null'
    | '{'
    | '}'
    | ';'
    | ','
    | '='
    | '('
    | ')'
    | '+'
    | '-'
    | '/'
    | '*'
    | '<'
    | '>'
    | '<='
    | '>='
    | '=='
    | '!='
    | '&&'
    | '||'
    | '!'
    | 'EOF'; // ç»“æŸæ ‡å¿—
```

ä¸‹é¢æ˜¯ `Token` çš„å®šä¹‰ï¼š
```ts
class Token {
    type: TokenType; // åƒæ“ä½œç¬¦ã€å…³é”®å­—ï¼ˆåŒ…å« true, false, null ç­‰ï¼‰ç”¨è¿™ä¸ªå¯ä»¥ç›´æ¥åŒºåˆ†ã€‚
    lexeme: string; // æ”¾åŸå§‹çš„è¯ç´ å­—ç¬¦ä¸²ã€‚
    literal: number | null; // ä»…ä»…å½“æ˜¯æ•°å­—æ—¶ï¼Œå°†æ•°å­—å­—ç¬¦ä¸²è½¬æˆæ•°å­—æ”¾è¿™é‡Œã€‚

    constructor(type: TokenType, lexeme: string, literal: number | null = null) {
        this.type = type;
        this.lexeme = lexeme;
        this.literal = literal;
    }
}
```

æ¥ä¸‹æ¥æˆ‘ä»¬æ¥é€å­—ç¬¦æ‰«æï¼Œäº§ç”Ÿ `Token` æ”¾åˆ° `tokens` æ•°ç»„ã€‚è¾“å…¥æ˜¯ `source`, æˆ‘ä»¬ç”¨ `index` æ¥ä»£è¡¨å½“å‰çš„æ‰«æä½ç½®ã€‚`scan` æ–¹æ³•çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œ`index` ä¸æ–­åç§»å¹¶æ‹¿åˆ°ä¸€ä¸ªå­—ç¬¦ã€‚ç„¶ååœ¨ `switch` ä¸­åšå†³æ–­ï¼Œè¿™ä¸ªå­—ç¬¦æ˜¯ä¸€ä¸ªä»€ä¹ˆè¯­æ³•æ ‡è®°ï¼Ÿ
```ts
class Scanner {
    private source: string;
    private index: number;
    private tokens: Token[];

    constructor(source: string) {
        this.source = source;
        this.index = 0;
        this.tokens = [];
    }

     scan(): Token[] {
        while (!this.isAtEnd()) {
            let c = this.advance(); // è¿”å›å½“å‰å­—ç¬¦ï¼Œå¹¶å°† index + 1
            switch (c) {
                case '{':
                case '}':
                case ',':
                case ';':
                case '(':
                case ')':
                case '*':
                case '/':
                case '+':
                case '-':
                    this.addToken(c, c); // æ„é€  Token å¹¶æ·»åŠ åˆ° tokens æ•°ç»„
                    break;
                // ... å…¶ä»–çš„å†³æ–­
                default:
                    // ...
                    throw new ScanError("Unknown token at: " + c);
            }
        }
        this.addToken('EOF', ''); // æœ«å°¾æ·»åŠ ç»ˆæ­¢ Token
        return this.tokens;
    }

    // çœç•¥äº†å·¥å…·å‡½æ•°
}
```
ä¸Šé¢ä»£ç å±•ç¤ºäº†æ‰«æå™¨çš„æ¶å­ã€‚`scan` æ–¹æ³•ä¸­å±•ç¤ºäº†å¤„ç†æœ€ç®€å•çš„ `Token` å¤„ç†â€”â€”å•ä¸ªå­—ç¬¦ä¾¿å¯ç¡®å®šçš„ç›´æ¥æ„é€ æ·»åŠ å³å¯ã€‚ç°åœ¨æˆ‘ä»¬æ¥çœ‹éº»çƒ¦ä¸€ç‚¹çš„ï¼š
* åƒ !=, ==, >=, <= è¿™æ ·ï¼Œå¿…é¡»è¦å…ˆçœ‹ç¬¬äºŒä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é… =, å¦åˆ™åº”è¯¥æ˜¯ !, =, >, <
* åƒ &&, || è¿™æ ·ï¼Œå¿…é¡»ä¸¤ä¸ªå­—ç¬¦éƒ½åŒ¹é…ï¼Œä»…ä»…åŒ¹é…ç¬¬ä¸€ä¸ªå­—ç¬¦çš„è¯ç›´æ¥æŠ¥é”™ï¼ˆæˆ‘ä»¬ä¸æ”¯æŒä½è¿ç®—å“¦ï¼‰

è¿™æ®µä»£ç ä¹Ÿä¸å¤æ‚ï¼š
```ts
// ...
switch (c) {
    // ...
    case '<':
    case '>':
        if (this.match('=')) { // match è¿”å›å½“å‰ä½ç½®æ˜¯å¦åŒ¹é…æŒ‡å®šçš„å­—ç¬¦ï¼Œå¹¶å°† index + 1
            c += '=';
        }
        this.addToken(c as TokenType, c);
        break;
    case '!':
        if (this.match('=')) {
            c += '=';
        }
        this.addToken(c as TokenType, c);
        break;
    case '=':
        if (this.match('=')) {
            const r = '==';
            this.addToken(r, r);
        } else {
            this.addToken(c, c);
        }
        break;
    case '&':
        if (this.match('&')) {
            const r = '&&';
            this.addToken(r, r);
            break;
        }
    case '|':
        if (this.match('|')) {
            const r = '||';
            this.addToken(r, r);
            break;
        }
        throw new ScanError("Unknown token at: " + c);
    // ...
}
// ...
```

å¯¹äºç©ºç™½å­—ç¬¦ï¼Œç›´æ¥è·³è¿‡å³å¯ï¼š
```ts
// ...
switch (c) {
    // ...
    case '\u0020':
    case '\n':
    case '\t':
        break;
    // ...
}
// ...
```

å½“çœ‹åˆ°åŒå¼•å·æ—¶ï¼Œè®¤ä¸ºæ˜¯å­—ç¬¦ä¸²ï¼Œç„¶åâ€œé™·å…¥â€ä¸€ä¸ªå±€éƒ¨å¾ªç¯ï¼Œä¸æ–­åç§» `index`, çŸ¥é“æ‰¾åˆ°ä¸‹ä¸€ä¸ªåŒå¼•å·ã€‚ä¸è¿‡è¦è€ƒè™‘è½¬ä¹‰å’Œåˆ°äº†ä»£ç ç»“å°¾ä¹Ÿæ²¡æ‰¾åˆ°çš„æƒ…å†µï¼Œç¼–è¯‘å™¨è¦èƒ½è¯†åˆ«é”™è¯¯ä»£ç å¹¶æŠ¥å‘Šï¼Œè€Œä¸æ˜¯å¥”æºƒï¼
```ts
class Scanner {
    // ...

    scan(): Token[] {
        // ...
        switch (c) {
            // ...
            case '"':
                this.addString();
                break;
            // ...
        }
        // ...
    }

    private addString() {
        let s = '';
        while (!this.isAtEnd() && this.current() !== '"') {
            if (this.current() === '\\') {
                this.advance();
                const c = this.advance();
                // https://en.wikipedia.org/wiki/Escape_character#:~:text=%5Bedit%5D-,JavaScript,-%5Bedit%5D
                if (ESCAPE_CHAR_MAP[c]) {
                    s += ESCAPE_CHAR_MAP[c];
                } else {
                    // \'
                    // \"
                    // \\
                    s += c;
                }
            } else {
                s += this.advance();
            }
        }

        if (this.isAtEnd()) {
            throw new ScanError('Unterminated string.');
        }

        // consume "
        this.advance();

        this.addToken('string', s);
    }

    //...
}

const ESCAPE_CHAR_MAP = {
    n: '\n',
    r: '\r',
    t: '\t',
    b: '\b',
    f: '\f',
    v: '\v',
    0: '\0',
} as const;
```

å¯¹äºæ•°å­—å’Œæ ‡å¿—ç¬¦çš„å¤„ç†æ¯”å­—ç¬¦ä¸²è¦ç®€å•ä¸€äº›ã€‚å¦‚æœå½“å‰å­—ç¬¦æ˜¯ä¸€ä¸ªæ•°å­—å­—ç¬¦ï¼Œåˆ™è®¤ä¸ºæ˜¯æ•°å­— `Token`ï¼Œç„¶åæ‰¾åˆ°æ•°å­—æœ«å°¾å¾—åˆ°å®Œæ•´æ•°å­—ã€‚å¦‚æœå½“å‰å­—ç¬¦æ˜¯ä¸€ä¸ªå­—æ¯å­—ç¬¦æˆ–è€…ä¸‹åˆ’çº¿å­—ç¬¦ï¼Œåˆ™è®¤ä¸ºæ˜¯æ ‡å¿—ç¬¦ `Token`ï¼Œç„¶åæ‰¾åˆ°æ ‡è¯†ç¬¦æœ«å°¾å¾—åˆ°å®Œæ•´çš„æ ‡å¿—ç¬¦ã€‚è¦æ³¨æ„çš„æ˜¯æ ‡å¿—ç¬¦ä»ç¬¬äºŒä¸ªå­—ç¬¦ä»¥åå¯ä»¥æ˜¯æ•°å­—ã€‚æ ‡å¿—ç¬¦åœ¨æ„é€  `Token` å‰ï¼Œè¿˜è¦åˆ¤æ–­æ˜¯ä¸æ˜¯å…³é”®å­—ï¼Œæ˜¯çš„è¯æ„é€ çš„å°±æ˜¯å…³é”®å­—çš„ `Token` äº†ã€‚
```ts
// ...
switch (c) {
    // ...
    default:
        if (this.isNumberChar(c)) {
            this.addNumber();
            break;
        } else if (this.isAlphaChar(c)) {
            this.addIdentifier();
            break;
        }
        throw new ScanError("Unknown token at: " + c);
}
// ...
```

ä»¥ä¸Šå°±æ˜¯ ts ç‰ˆæœ¬çš„åˆ†è¯çš„å…¨éƒ¨äº†ã€‚æ˜¯ä¸æ˜¯å¾ˆç®€å•ğŸ˜„ã€‚å®Œæ•´ä»£ç ï¼Œè¯·çœ‹ [ts-scanner](https://github.com/huanguolin/toc/blob/master/ts-toc/Scanner/index.ts).


##### 2.2.2.2 åˆ†è¯ï¼ˆtypeç‰ˆï¼‰

ç°åœ¨è¯¥ type ç‰ˆäº†ã€‚é¦–å…ˆæ˜¯ `Token` çš„å®šä¹‰ï¼š
```ts
// TokenType å’Œ ts ç‰ˆå®Œå…¨ä¸€è‡´ï¼Œåœ¨æ­¤çœç•¥ã€‚

interface Token {
    type: TokenType,
    lexeme: string,
    value: number | null,
}

// æ–¹ä¾¿æ„é€  Token çš„å·¥å…·å‡½æ•°
interface BuildToken<
    Type extends TokenType,
    Lexeme extends string,
> extends Token {
    type: Type,
    lexeme: Lexeme,
    value: Eq<Type, 'number'> extends true ? Str2Num<Safe<Lexeme, NumStr>> : null, // Str2Num æ€ä¹ˆå®ç°ï¼Œåœ¨è®²å››åˆ™è¿ç®—çš„æœ«å°¾æœ‰æåˆ°
}

// EOF ç›´æ¥å®šä¹‰å‡ºæ¥æ–¹ä¾¿ç”¨
type EOF = BuildToken<'EOF', ''>;
```

å®ƒä¹Ÿå¯ä»¥é€å­—ç¬¦æ¥åˆ†æã€‚é‚£ä¹ˆæ€ä¹ˆå–ä¸€ä¸ªå­—ç¬¦å‘¢ï¼Ÿ
```ts
type FirstChar<T extends string> =
    T extends `${infer First}${infer Rest}`
        ? [First, Rest]
        : never;
type test_first_char_1 = FirstChar<'1 + 2'>; // ['1', ' + 2']
type test_first_char_2 = FirstChar<test_first_char_1[1]>; // [' ', '+ 2']
type test_first_char_3 = FirstChar<test_first_char_2[1]>; // ['+', ' 2']
type test_first_char_4 = FirstChar<test_first_char_3[1]>; // [' ', '2']
type test_first_char_5 = FirstChar<test_first_char_4[1]>; // ['2', '']
type test_first_char_6 = FirstChar<test_first_char_5[1]>; // never
```
ä»¥ä¸Šå°±æ˜¯é€å­—ç¬¦å–å‡ºçš„ä»£ç ã€‚å’Œ ts ç‰ˆä¸­ `scan` å‡½æ•°çš„å¾ªç¯å–å‡ºæ¯”å‘¢ï¼Ÿæœ‰ç›¸ä¼¼ä¹‹å¤„ï¼Œåˆæ˜æ˜¾çš„ä¸åŒã€‚
ç›¸ä¼¼æ˜¯ä¸¤è€…éƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦çš„å–å‡ºæ¥ã€‚å·®å¼‚æ˜¯ï¼Œts ç‰ˆä¸­ä¾é çš„æ˜¯ `index` ç›´æ¥æ¥å–ç›¸åº”ä½ç½®çš„å­—ç¬¦ï¼Œéšç€ `index` å€¼å¢åŠ ï¼Œè€Œå–çš„å­—ç¬¦ä½ç½®é€æ¸åç§»ã€‚ç±»å‹ç³»ç»Ÿä¸­å´æ²¡æœ‰ä¸€ä¸ªæœºåˆ¶å¯ä»¥ç›´æ¥å–æŸä¸ªä½ç½®çš„å­—ç¬¦ã€‚å¦‚æœæˆ‘ä»¬éè¦å®ç°ï¼Œä¹Ÿèƒ½åˆ©ç”¨ä¸Šé¢é€å­—ç¬¦å–åŠ ä¸Šè®¡æ•°çš„åŠæ³•è¾¾åˆ°ç±»ä¼¼çš„æ•ˆæœã€‚ä½†æ˜¯æ•ˆç‡å¾ˆä½ï¼Œ`index` æ¯åç§»ä¸€ä½ï¼Œå°±è¦ä»å¤´éå†ä¸€éã€‚

æ‰€ä»¥æˆ‘ä»¬ä¸è¦ `index` åç§»çš„æ–¹æ¡ˆã€‚å°±ç›´æ¥æ¯æ¬¡å–ä¸€ä¸ªå­—ç¬¦æ¥åšâ€œæ£€æµ‹â€ã€‚ç±»å‹ç³»ç»Ÿæ²¡æœ‰ `switch` è¯­å¥ï¼Œåªèƒ½ç”¨æ¡ä»¶è¯­å¥ä¸€ä¸ªä¸€ä¸ªæ£€æŸ¥ã€‚è¿˜è¦æŠŠå–å‰©ä¸‹çš„å­—ç¬¦ä¸²ä¿ç•™ä¸‹æ¥ï¼Œä¸‹ä¸€ä¸ªå¾ªç¯éœ€è¦å®ƒã€‚ä½†æ˜¯åƒ `!=` è¿™æ ·çš„éœ€è¦åçœ‹ä¸€ä½ï¼Œåˆè¦å†å–ä¸€ä¸ªâ€¦â€¦è¿™åšè‚¯å®šæ˜¯å¯ä»¥åšå‡ºæ¥çš„ï¼Œä½†æ˜¯æƒ³æƒ³ä»£ç å†™å‡ºæ¥çš„æ ·å­ï¼Œå•Šï¼Œå¾ˆæ··ä¹±ğŸ˜«â€¦â€¦æ€è·¯ä¸æ¸…æ™°ï¼

åˆ«æ€¥ï¼Œæˆ‘æ¥é‡æ–°æ¢³ç†ä¸€ä¸‹ã€‚ä¸€ä¸ªä¸€ä¸ªå–å­—ç¬¦æ˜¯æ²¡é—®é¢˜çš„ã€‚ä½†æ˜¯è¦è®©ä»£ç å¯è¯»æ€§å¥½ï¼Œå¯ä»¥æŠŠè§£æä¸åŒç§ç±» `token` çš„ä»£ç ï¼ŒæŒ‰ç§ç±»æŠ½æˆä¸€ä¸ªä¸€ä¸ªçš„å‡½æ•°ã€‚é‚£é€‰ç”¨å“ªä¸ªå‡½æ•°è¿˜è¦åšä¸€ä¸ªé¢„åˆ¤æ–­ï¼Ÿé‚£ä¸åˆæ˜¯ä¸€å †çš„æ¡ä»¶åˆ¤æ–­â€¦â€¦é¢ï¼Œæˆ–è®¸æˆ‘ä»¬ä¸éœ€è¦é¢„åˆ¤æ–­ã€‚ç›´æ¥æŒ¨ä¸ªå°è¯•è§£æï¼Œè§£å‡ºæ¥å°±è¿›è¡Œä¸‹ä¸€ä¸ªå¾ªç¯ï¼Œå¦åˆ™å°±æ¢ä¸‹ä¸€ä¸ªç§ç±»ã€‚

å—¯ï¼Œä¸é”™ğŸ˜„ï¼é‚£æ€ä¹ˆçŸ¥é“èƒ½è§£æå‡ºæ¥å‘¢ï¼Ÿå½“ç„¶æ˜¯çœ‹è¿”å›å€¼äº†ã€‚åˆ«å¿˜äº†æˆ‘ä»¬æœ‰æ¨¡å¼åŒ¹é…ï¼Œå¦‚æœè¿”å›å€¼ç¬¦åˆæˆåŠŸçš„ç»“æ„ï¼Œå°±è§£å‡ºæ¥äº†ï¼Œæˆ‘ä»¬é¡ºä¾¿ä»é‡Œé¢æ‹¿åˆ° `Token` å’Œ `Rest` å­—ç¬¦ä¸²ã€‚`Token` è¿½åŠ åˆ°ç»“æœæ•°ç»„ä¸­ï¼Œ`Rest` ç”¨äºä¸‹ä¸€ä¸ªå¾ªç¯çš„å…¥å‚ã€‚
```ts
// S æ˜¯ sourceCode, A æ˜¯å­˜æ”¾ç»“æœçš„ array
type Scan<S extends string, A extends Token[] = []> =
    S extends ''
        ? Push<A, EOF> // åˆ°ç»“å°¾äº†
        : S extends `${infer Space extends SpaceChars}${infer Rest}`
            ? Scan<Rest, A> // æ’é™¤ç©ºç™½å­—ç¬¦
            : ScanBody<S, A>; // ä¸æ˜¯ç©ºç™½å­—ç¬¦ï¼Œå°±æ¥å°è¯•è§£æ

type ScanBody<S extends string, A extends Token[] = []> =
    ScanNumber<S> extends ScanSuccess<infer T, infer R> // å°è¯• number
        ? Scan<R, Push<A, T>>
        : ScanOperator<S> extends ScanSuccess<infer T, infer R> // å°è¯•æ“ä½œç¬¦
            ? Scan<R, Push<A, T>>
            : ScanIdentifier<S> extends ScanSuccess<infer T, infer R> // å°è¯•æ ‡å¿—ç¬¦ï¼ŒåŒæ ·å«å…³é”®å­—
                ? Scan<R, Push<A, T>>
                : ScanString<S> extends ScanSuccess<infer T, infer R> // å°è¯•å­—ç¬¦ä¸²
                    ? Scan<R, Push<A, T>>
                    : ScanError<`Unknown token at: ${S}`>; // å°è¯•å®Œæ‰€æœ‰æƒ…å†µï¼Œä¹Ÿæ— æ³•è§£æï¼Œåˆ™å¾—åˆ°ä¸€ä¸ªé”™è¯¯
```

ä¸Šé¢å°±æ˜¯å¤§çš„æ¶å­ã€‚å…¶ä¸­æœ‰äº›å·¥å…·å‡½æ•°ï¼Œ`Push` åº”è¯¥ä¸ç”¨è¯´äº†ã€‚é‡ç‚¹æ˜¯ `ScanSuccess` å’Œ `ScanError`ã€‚æœ‰å®ƒä»¬æ‰çŸ¥é“è§£æçš„ç»“æœå¦‚ä½•ã€‚å®ƒä»¬å…¶å®ä½¿ç”¨äº†æ›´åŸºç¡€çš„ç»“æœåŒ…è£…å‡½æ•°ï¼Œåé¢çš„è¯­æ³•åˆ†æå’Œæ‰§è¡Œï¼Œéƒ½è¦ç”¨åˆ°ã€‚
```ts
// å…¨å±€ç»“æœåŒ…è£…ğŸ”§å‡½æ•°
type ErrorResult<E> = { type: 'Error', error: E };
type SuccessResult<R> = { type: 'Success', result: R };

// ç”¨æ¥ä»£æ›¿ never çš„ï¼Œå¸¦ä¸€ä¸ªåå­—å‚æ•°ã€‚åˆ°åé¢ä½ å°±çŸ¥é“ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨ never äº†â€¦â€¦
type NoWay<Name extends string> = `[${Name}] impossible here!`;
```

å†æ¥çœ‹ `ScanSuccess` å’Œ `ScanError`ï¼š
```ts
type ScanError<M extends string> = ErrorResult<`[ScanError]: ${M}`>;
type ScanSuccess<T extends Token, R extends string> = SuccessResult<{ token: T, rest: R }>;
```

æœ‰ä¸ªé—®é¢˜ï¼Œä¸ç”¨è¿™äº›ç»“æœåŒ…è£…å‡½æ•°å¯ä»¥å—ï¼Ÿå½“ç„¶æ˜¯å¯ä»¥çš„ï¼ä½†æ˜¯ä¼šå¾ˆå•°å—¦ï¼Œè¿˜å®¹æ˜“æ‰‹è¯¯ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œç”¨å·¥å…·è¿˜æœ‰å¦‚ä¸‹çš„ä¼˜åŠ¿ï¼š
```ts
// è¿™é‡Œ T å’Œ R çš„ç±»å‹æ˜¯ç¡®å®šçš„ï¼Œä¸éœ€è¦è¿›ä¸€æ­¥é™å®šã€‚å› ä¸º ScanSuccess åœ¨å®šä¹‰æ—¶å°±é™å®šäº†ç±»å‹ã€‚
type test = ScanNumber<S> extends ScanSuccess<infer T, infer R>

// ä¸ç”¨å·¥å…·å‡½æ•°ï¼Œè¦ç”¨ extends é™å®šæ‰è¡Œã€‚
type test = ScanNumber<S> extends { token: T extends Token, rest: R extends string }
```

å¥½äº†ï¼Œå›å½’æ­£é¢˜ã€‚æˆ‘ä»¬çœ‹çœ‹å…·ä½“çš„è§£æå‡½æ•°ï¼Œå…ˆæ˜¯ `ScanNumber`ï¼Œå¾ˆç®€å•ï¼š
```ts
type ScanNumber<S extends string, N extends string = ''> =
    S extends `${infer C extends NumChars}${infer R extends string}`
        ? ScanNumber<R, `${N}${C}`>
        : N extends ''
            ? ScanError<'Not match a number.'>
            : ScanSuccess<BuildToken<'number', N>, S>;
```

`ScanOperator` è¦å¤æ‚ä¸€äº›ï¼Œé‡ç‚¹åœ¨æ¨¡å¼åŒ¹é…ã€‚è¦æ³¨æ„çš„æ˜¯å•å­—ç¬¦çš„æ“ä½œç¬¦æ”¾åˆ°æœ€åï¼Œè¦ä¼˜å…ˆåŒ¹é…æ›´é•¿çš„ï¼š
```ts
type ScanOperator<S extends string> =
    S extends OpGteOrLte<infer C1, infer C2, infer R>
        ? ScanSuccess<BuildToken<`${C1}${C2}`, `${C1}${C2}`>, R>
        : S extends OpEqOrNot<infer C1, infer C2, infer R>
            ? ScanSuccess<BuildToken<`${C1}${C2}`, `${C1}${C2}`>, R>
            : S extends OpAnd<infer C1, infer C2, infer R>
                ? ScanSuccess<BuildToken<`${C1}${C2}`, `${C1}${C2}`>, R>
                : S extends OpOr<infer C1, infer C2, infer R>
                    ? ScanSuccess<BuildToken<`${C1}${C2}`, `${C1}${C2}`>, R>
                    : S extends `${infer C extends SingleOperators}${infer R extends string}`
                        ? ScanSuccess<BuildToken<Safe<C, SingleOperators>, C>, R>
                        : ScanError<'Not match an operator.'>;

type SingleOperators =
    | '{'
    | '}'
    | ','
    | ';'
    | '('
    | ')'
    | '+'
    | '-'
    | '/'
    | '*'
    | '%'
    | '<'
    | '>'
    | '!'
    | '=';

type OpGteOrLte<C1 extends '>' | '<', C2 extends '=', R extends string> = `${C1}${C2}${R}`;
type OpEqOrNot<C1 extends '=' | '!', C2 extends '=', R extends string> = `${C1}${C2}${R}`;
type OpAnd<C1 extends '&', C2 extends '&', R extends string> = `${C1}${C2}${R}`;
type OpOr<C1 extends '|', C2 extends '|', R extends string> = `${C1}${C2}${R}`;
```

`ScanIdentifier` å’Œ `ScanString` ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œå°±ä¸å†è´´ä»£ç äº†ï¼Œå®Œæ•´ç‰ˆè¯·çœ‹ [type-Scanner](https://github.com/huanguolin/toc/blob/master/type-toc/scanner/index.d.ts)ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬çš„è¯æ³•åˆ†æå·²ç»å…¨éƒ¨å®Œæˆã€‚æ˜¯ä¸æ˜¯æ¸å…¥ä½³å¢ƒğŸ˜Šã€‚æ¥ä¸‹æ¥ï¼Œå°±è®©æˆ‘ä»¬â€œæ”€ç™»â€æœ¬æ¬¡æœ€é«˜çš„â€œå±±å³°â€â€”â€”è¯­æ³•åˆ†æï¼


#### 2.2.3 è¯­æ³•åˆ†æ
ä¸ºäº†ä½ ï¼Œä¹Ÿä¸ºäº†æˆ‘ï¼Œèƒ½å¹³æ»‘çš„å®Œæˆè¿™ä»¶äº‹æƒ…ï¼Œæˆ‘ä»¬ä»æå®šè¡¨è¾¾å¼å¼€å§‹ã€‚å…ˆçœ‹ä¸€ä¸ªç®€å•çš„å››åˆ™è¿ç®—ï¼š
```ts
10 - 2 * 3 + 1
// æŒ‰ç…§ä¼˜å…ˆçº§ï¼Œå¯¹åº”çš„æŠ½è±¡è¯­æ³•æ ‘:
//     +
//    / \
//   -   1
//  /  \
// 10   *
//     / \
//    2   3
```

ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·çš„æ ‘ï¼Œè€Œä¸æ˜¯å¦å¤–ä¸€ä¸ªå‘¢ï¼Ÿæ˜¯å› ä¸ºä¼˜å…ˆçº§é«˜çš„è¦å…ˆè¿ç®—ï¼Œåœ¨è¯­æ³•æ ‘ä¸­ï¼Œåªæœ‰æ“ä½œæ•°éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼ˆæ­¤æ—¶å®ƒä»¬éƒ½æ˜¯å­—é¢é‡ï¼Œæ— æ³•ç»§ç»­å±•å¼€ä¸ºåˆ«çš„è¡¨è¾¾å¼ï¼‰æ—¶ï¼Œæ‰èƒ½è¿ç®—ã€‚è¿ç®—æ—¶ï¼Œä»æœ€æ·±çš„è¿ç®—ç¬¦èŠ‚ç‚¹å¼€å§‹ï¼Œå…ˆå·¦åå³ï¼Œå‘æ ‘æ ¹é æ‹¢ï¼š
```ts
//     +
//    / \
//   -   1
//  /  \
// 10   *
//     / \
//    2   3
// ========>
//     +
//    / \
//   -   1
//  /  \
// 10   6
// ========>
//     +
//    / \
//   4   1
// ========>
//     5
```

åœ¨æ„å»ºè¿™æ ·çš„è¯­æ³•æ ‘ä¹‹å‰ï¼Œéœ€è¦å…ˆå®šä¹‰è¯­æ³•æ ‘çš„èŠ‚ç‚¹ã€‚ä¸Šé¢çš„è¡¨è¾¾å¼ä¸­åŒ…å«äº†ä¸¤ç§åŸºç¡€çš„è¡¨è¾¾å¼ï¼š
* å­—é¢é‡è¡¨è¾¾å¼
* äºŒå…ƒè¡¨è¾¾å¼

æ­¤å¤–æˆ‘ä»¬è¿˜æœ‰ä¸€å…ƒè¡¨è¾¾å¼å’Œåˆ†ç»„è¡¨è¾¾å¼ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆå®šä¹‰è¡¨è¾¾å¼ç±»å‹å’Œè¡¨è¾¾å¼çš„æ¥å£ï¼š
```ts
type ExprType =
    | 'group'
    | 'binary'
    | 'unary'
    | 'literal';

interface IExpr {
    type: ExprType;
}
```

ä¸‹é¢ï¼Œæˆ‘ä»¬ä¾æ¬¡æ¥å®šä¹‰å­—é¢é‡ã€ä¸€å…ƒã€äºŒå…ƒã€åˆ†ç»„è¡¨è¾¾å¼ï¼š
```ts
type ValueType =
    | string
    | number
    | boolean
    | null;

class LiteralExpr implements IExpr {
    type: ExprType = 'literal';
    value: ValueType;

    constructor(value: ValueType) {
        this.value = value;
    }
}

class UnaryExpr implements IExpr {
    type: ExprType = 'unary';
    operator: Token;
    expression: IExpr;

    constructor(operator: Token, expr: IExpr) {
        this.operator = operator;
        this.expression = expr;
    }
}

class BinaryExpr implements IExpr {
    type: ExprType = 'binary';
    left: IExpr;
    operator: Token;
    right: IExpr;

    constructor(left: IExpr, operator: Token, right: IExpr) {
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
}

class GroupExpr implements IExpr {
    type: ExprType = 'group';
    expression: IExpr;

    constructor(expr: IExpr) {
        this.expression = expr;
    }
}
```

ç°åœ¨å›åˆ° `10 - 2 * 3 + 1` è¿™ä¸ªè¡¨è¾¾å¼ï¼ŒæœŸæœ›çš„è¯­æ³•æ ‘åº”è¯¥è¡¨ç¤ºä¸ºï¼š
```ts
const mulExpr = new BinaryExpr(
    new LiteralExpr(2),
    new Token('*', '*'),
    new LiteralExpr(3));

const minusExpr = new BinaryExpr(
    new LiteralExpr(10),
    new Token('-', '-'),
    mulExpr);

const addExpr = new BinaryExpr(
    minusExpr,
    new Token('+', '+'),
    new LiteralExpr(1));

// æœ€ç»ˆè¾“å‡ºçš„è¯­æ³•æ ‘ï¼š
const expression = addExpr;
```

å¯æ˜¯æˆ‘ä»¬è¦ç”¨ä»£ç æ¥äº§ç”Ÿè¿™ä¸ªï¼`Parser` çš„è¾“å…¥æ˜¯ `Token` æ•°ç»„ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆå°±æ˜¯è¯­æ³•æ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰ã€‚æ¶å­ä»£ç å¦‚ä¸‹ï¼š
```ts
class Parser {
    private tokens: Token[];
    private index: number;

    constructor(tokens: Token[]) {
        this.tokens = tokens;
        this.index = 0;
    }

    parse(): IExpr {
        return this.expression();
    }

    private expression(): IExpr {
        // TODO
    }
}
```
##### 2.2.3.1 é€’å½’ä¸‹é™

`expression` å‡½æ•°æ€ä¹ˆå®ç°å‘¢ï¼Ÿè¿™å°±æ˜¯è¯­æ³•åˆ†æçš„å…³é”®äº†ã€‚å­¦è¿‡ç¼–è¯‘åŸç†çš„åŒå­¦çŸ¥é“ï¼Œè¯­æ³•åˆ†ææœ‰å¾ˆå¤šç®—æ³•ã€‚ä½†æ˜¯æ‰‹å†™è¯­æ³•åˆ†æï¼Œç®€å•åˆå®ç”¨ï¼Œå¿…é¡»è¦æŒæ¡çš„ï¼Œè«å±[é€’å½’ä¸‹é™](https://en.wikipedia.org/wiki/Recursive_descent_parser)äº†ã€‚å®ƒæ˜¯[è‡ªé¡¶å‘ä¸‹è¯­æ³•åˆ†æ](https://en.wikipedia.org/wiki/Top-down_parsing)çš„ä¸€ç§ã€‚

ä¸ºä»€ä¹ˆé€’å½’ä¸‹é™æ˜¯è‡ªé¡¶å‘ä¸‹å‘¢ï¼Ÿå› ä¸ºé€’å½’ä¸‹é™ä» `expression` å¼€å§‹ï¼Œé€æ­¥å±•å¼€ä¸ºæ›´å…·ä½“çš„è¡¨è¾¾å¼ï¼Œç›´åˆ°æ— æ³•å±•å¼€ä¸ºæ­¢ã€‚

æˆ‘ä»¬é…åˆä¾‹å­ï¼Œä¸€æ­¥ä¸€æ­¥æ¥ï¼Œä¼šæ›´å¥½ç†è§£é€’å½’ä¸‹é™ã€‚

å‡å¦‚åªè€ƒè™‘å››åˆ™è¿ç®—ï¼ŒåŠ ä¸Šæ•°å­—ï¼Œåªæœ‰ä¸‰ä¸ªä¼˜å…ˆçº§ï¼Œä»ä½åˆ°é«˜æ’åˆ—ï¼š
1. åŠ æ€§è¿ç®—(additive)ï¼š+ï¼Œ-
2. ä¹˜æ€§è¿ç®—(factor)ï¼š*, /
3. å­—é¢é‡(literal): NUMBER

å‰é¢çš„ä¾‹å­ï¼Œ`10 - 2 * 3 + 1`, å¦‚æœç”¨é€’å½’ä¸‹é™æ¥è€ƒè™‘ï¼Œå¯ä»¥çœ‹æˆï¼š
```ts
10 - factor_1 + 1
// factor_1 = 2 * 3
```
å¦‚æœæ˜¯ `10 / 5 - 2 * 3 + 1`ï¼Œå°±çœ‹æˆï¼š
```ts
factor_1 - factor_2 + 1
// factor_1 = 10 / 5
// factor_2 = 2 * 3
```
æˆ–è€…ï¼š
```ts
factor_1 - factor_2 + factor_3
// factor_1 = 10 / 5
// factor_2 = 2 * 3
// factor_3 = 1
```
æ³¨æ„ï¼Œè¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œæˆ‘ä»¬æŠŠé—®é¢˜æŠ½è±¡åŒ–äº†ï¼Œå˜æˆåªæœ‰ä¸€ç§ä¼˜å…ˆçº§çš„è¿ç®—ã€‚ä»»ä½•å››åˆ™è¿ç®—éƒ½å¯ä»¥æŠ½è±¡æˆè¿™æ ·ï¼Œæˆ‘ä»¬å†çœ‹å‡ ä¸ªä¾‹å­ï¼š
```ts
2 + 3
factor_1 + factor_2
// factor_1 = 2
// factor_2 = 3

2 * 3 / 4
factor_1
// factor_1 = 2 * 3 / 4

5
factor_1
// factor_1 = 5
```
æ‰€ä»¥æˆ‘åªéœ€è¦è€ƒè™‘ç›¸åŒä¼˜å…ˆçº§çš„è¿ç®—ï¼Œç›´æ¥ä»å·¦åˆ°å³å³å¯ã€‚å‡è®¾æœ‰ `factor_1 - factor_2 + factor_3`, å¾—åˆ°çš„ä»£ç æ ‘å¦‚ä¸‹ï¼š
```ts
factor_1 - factor_2 + factor_3
//          +
//         / \
//         -   factor_3
//        / \
// factor_1  factor_2
```
æ³¨æ„ç›¸åŒä¼˜å…ˆçº§ï¼Œä»å·¦åˆ°å³è®¡ç®—ï¼Œç›¸å½“äºè¯´ä»å·¦åˆ°å³ï¼Œä¼˜å…ˆçº§ä¾æ¬¡é™ä½ã€‚æ‰€ä»¥æœ€å³è¾¹çš„è¿ç®—æ˜¯æ ¹ã€‚æ‰€ä»¥å¯¹äºåŠ æ€§è¿ç®—çš„é€’å½’ä¸‹é™ä»£ç å¦‚ä¸‹ï¼š
```ts
class Parser {
    // ...
    private expression(): IExpr {
        return this.additive();
    }

    private additive(): BinaryExpr {
        let expr = this.factor();
        while (this.match('+', '-')) { // åŒ¹é…åˆ° + æˆ–è€… -
            const left = expr;
            const operator = this.previous(); // è¿”å› + æˆ–è€… - çš„ Token
            const right = this.factor();
            expr = new BinaryExpr(left, operator, right);
        }
        return expr;
    }

    private factor(): BinaryExpr {
        // TODO
    }

    private match(...tokenTypes: TokenType[]) {
        if (this.check(...tokenTypes)) {
            this.advance();
            return true;
        }
        return false;
    }

    private check(...tokenTypes: TokenType[]): boolean {
        if (this.isAtEnd()) {
            return false;
        }
        return tokenTypes.includes(this.current().type);
    }

    private isAtEnd() {
        return this.tokens[this.index].type === 'EOF';
    }

    private advance() {
        return this.tokens[this.index++];
    }

    private current() {
        return this.tokens[this.index];
    }

    private previous() {
        return this.tokens[this.index - 1];
    }
}
```
ä½ å¯ä»¥æŠŠä¸Šé¢ä¸¾çš„å¤šä¸ªä¾‹å­å¥—è¿›å»çœ‹çœ‹ã€‚

åŒç†ï¼Œæˆ‘ä»¬å¤„ç†ä¹˜æ€§è¿ç®—ä¹Ÿæ˜¯ä¸€æ ·ï¼š
```ts
2 * 3 / 4
literal_1 * literal_2 / literal_3
// literal_1 = 2
// literal_2 = 3
// literal_3 = 4

5
literal_1
// literal_1 = 5
```
ä»£ç å’ŒåŠ æ€§è¿ç®—å‡ ä¹ä¸€æ ·ï¼š
```ts
class Parser {
    // ...
    private additive(): BinaryExpr {
        let expr = this.factor();
        while (this.match('+', '-')) { // åŒ¹é…åˆ° + æˆ–è€… -
            const left = expr;
            const operator = this.previous(); // è¿”å› + æˆ–è€… - çš„ Token
            const right = this.factor();
            expr = new BinaryExpr(left, operator, right);
        }
        return expr;
    }

    private factor(): BinaryExpr {
        let expr = this.literal();
        while (this.match('*', '/')) { // åŒ¹é…åˆ° * æˆ–è€… /
            const left = expr;
            const operator = this.previous(); // è¿”å› * æˆ–è€… / çš„ Token
            const right = this.literal();
            expr = new BinaryExpr(left, operator, right);
        }
        return expr;
    }

    private literal(): LiteralExpr() {
        // TODO
    }
    // ...
}
```
æœ€ååˆ°åªè€ƒè™‘æ•°å­—çš„å­—é¢é‡å°±æ›´ç®€å•äº†ï¼š
```ts
class Parser {
    // ...
    private literal(): LiteralExpr() {
        if (this.match('number')) {
            return new LiteralExpr(this.previous().literal as number);
        }

        throw new ParseError(`Expect expression, but got token: ${this.current().lexeme}.`);
    }
    // ...
}
```
å¦‚æœä½ çœ‹æ‡‚äº†ä¸Šé¢ï¼Œä½ å°±çœ‹æ‡‚äº†é€’å½’ä¸‹é™ã€‚ç°åœ¨æˆ‘ä»¬æ¥æ€»ç»“é€’å½’ä¸‹é™ç®—æ³•æ˜¯æ€ä¹ˆåšçš„ï¼š
1. å°†è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ä»ä½åˆ°é«˜æ’åˆ—ï¼›
2. ä»æœ€ä½çš„ä¼˜å…ˆçº§å¼€å§‹è§£æï¼Œå‘æœ€é«˜ä¼˜å…ˆçº§â€œä¸‹é™â€ï¼›
3. è§£ææŸç§ä¼˜å…ˆçº§çš„è¿ç®—æ—¶ï¼Œåªâ€œçœ‹åˆ°â€ç›¸åŒä¼˜å…ˆçº§çš„è¿ç®—ç¬¦ï¼Œä¸”æ“ä½œæ•°éƒ½æ˜¯æ›´é«˜ä¼˜å…ˆçº§çš„è¿ç®—ã€‚
4. â€œä¸‹é™â€æœ€ç»ˆä¼šè½åˆ°æ— æ³•ç»§ç»­å®æ–½è¡¨è¾¾å¼å±•å¼€çš„å­—é¢é‡ä¸Šã€‚

ä¸Šé¢æˆ‘ä»¬å®ç°äº†å››åˆ™è¿ç®—çš„é€’å½’ä¸‹é™ä»£ç ï¼Œç”¨è¯­æ³•å®šä¹‰æ¥æè¿°è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯ï¼š
```shell
expression      â†’ additive ;
additive        â†’ factor ( ( "-" | "+" ) factor )* ;
factor          â†’ literal ( ( "/" | "*" ) literal )* ;
literal         â†’ NUMBER ;
```
> ç°åœ¨å»çœ‹ [Toc Grammar Spec](https://github.com/huanguolin/toc/blob/master/docs/grammar.md), æ˜¯ä¸æ˜¯èƒ½çœ‹æ‡‚æ›´å¤šäº†ğŸ˜‚

##### 2.2.3.2 å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æ(tsç‰ˆæœ¬)

ç°åœ¨ï¼Œè¦å®ç°å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æï¼Œæˆ‘ä»¬å…ˆå°†è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ä»ä½åˆ°é«˜æ’åˆ—ï¼š
```ts
// è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ç”±ä½åˆ°é«˜ï¼š
// logic or:    ||                  å·¦ç»“åˆ
// logic and:   &&                  å·¦ç»“åˆ
// equality:    == !=               å·¦ç»“åˆ
// relation:    < > <= >=           å·¦ç»“åˆ
// additive:    + -                 å·¦ç»“åˆ
// factor:      * / %               å·¦ç»“åˆ
// unary:       !                   å³ç»“åˆ
// primary:     literal group
```
æ³¨æ„åˆ°å—ï¼Ÿ`primary: literal group`, `literal` å’Œ `group` ä¸€ä¸ªä¼˜å…ˆçº§ï¼Ÿç­”æ¡ˆè‚¯å®šçš„ã€‚è€Œä¸”è¿™ä¸¤ä¸ªåœ¨ä¸€èµ·äº†ï¼ŒåŸæ¥å« `literal` çš„å‡½æ•°åå­—å°±å¿…é¡»è¦æ”¹äº†ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹ä»£ç å§ï¼š
```ts
class Parser {
    // ...
    private factor(): BinaryExpr {
        let expr = this.primary();
        while (this.match('*', '/', '%')) { // é¡ºå¸¦åŠ ä¸Šå¯¹å–ä½™è¿ç®—ç¬¦çš„æ”¯æŒ
            const left = expr;
            const operator = this.previous();
            const right = this.primary();
            expr = new BinaryExpr(left, operator, right);
        }
        return expr;
    }

    private primary(): LiteralExpr() {
        if (this.match('number')) {
            return new LiteralExpr(this.previous().literal as number);
        } else if (this.match('true', 'false', 'null')) {
            const type = this.previous().type;
            if (type === 'null') {
                return new LiteralExpr(null);
            }
            return new LiteralExpr(type === 'true');
        } else if (this.match('string')) {
            return new LiteralExpr(this.previous().lexeme);
        } else if (this.match('(')) {
            const expr = this.expression(); // æ³¨æ„è¿™é‡Œé€’å½’è°ƒç”¨äº† expression()
            this.consume(')', 'Expect ")" after expression.');
            return new GroupExpr(expr);
        }

        throw new ParseError(`Expect expression, but got token: ${this.current().lexeme}.`);
    }
    // ...
    private consume(tokenType: TokenType, message: string) {
        if (this.check(tokenType)) {
            this.advance();
            return;
        }
        throw new ParseError(message);
    }
    // ...
}
```

ä¸‹é¢ï¼Œé€»è¾‘è¿ç®—ï¼Œæ¯”è¾ƒè¿ç®—çš„ä»£ç å’ŒåŠ æ³•ä¹˜æ³•å®Œå…¨ä¸€è‡´ï¼Œåªéœ€è¦æŒ‰ç…§ä¼˜å…ˆçº§é¡ºåºç¼–å†™å³å¯ï¼Œå°±ä¸å†èµ˜è¿°ã€‚æœ€ååªå‰©ä¸‹ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦äº†ã€‚è¿™ä¸ªæœ‰ç‚¹ç‰¹æ®Šï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ã€‚

å®ƒç‰¹æ®Šåœ¨é‚£é‡Œå‘¢ï¼Ÿä¸€å…ƒï¼Ÿé¢â€¦â€¦æ³¨æ„å®ƒçš„ç»“åˆæ€§ï¼Œå’ŒäºŒå…ƒè¿ç®—éƒ½ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯å³ç»“åˆï¼Œä¸¾ä¸ªä¾‹å­ï¼š
```ts
!!false

// ç­‰ä»·äºï¼š
!(!false)

// ç­‰ä»·äºï¼š
!(!literal_1)
literal_1 = false

// ç­‰ä»·äºï¼š
!unary_1
unary_1 = !literal_1
literal_1 = false

// AST:
//  ! <- å·¦èµ·ç¬¬ä¸€ä¸ª
//  |
//  ! <- å·¦èµ·ç¬¬äºŒä¸ª
//  |
//  false
```
çœ‹åˆ°å—ï¼Œ`!` åé¢è¿˜å¯ä»¥æ˜¯ä¸€ä¸ª `!` è¡¨è¾¾å¼ï¼Œå®ƒåœ¨é€’å½’è‡ªå·±ï¼Œè¿™å°±æ˜¯å®ƒä¸ä¼—ä¸åŒçš„åœ°æ–¹ã€‚ä»£ç å¦‚ä¸‹ï¼š
```ts
class Parser {
    // ...
    private unary(): UnaryExpr {
        if (this.match('!')) {
            const operator = this.previous();
            const right = this.unary();
            return new UnaryExpr(operator, right);
        }
        return this.primary();
    }
    // ...
```

å¥½äº†ï¼Œä»¥ä¸Šå°±æ˜¯ ts ç‰ˆæœ¬çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æï¼Œå®Œæ•´ä»£ç è§ [ts-Parser-expression](https://github.com/huanguolin/toc/blob/0f32d4cecf0314e12cd1798293048c2a7e56bfe6/ts-toc/Parser/index.ts#L167)ã€‚

##### 2.2.3.3 å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•åˆ†æ(typeç‰ˆæœ¬)

å‚ç…§ ts ç‰ˆæœ¬ï¼Œæˆ‘ä»¬æ¥å®ç° type ç‰ˆçš„è¡¨è¾¾å¼è¯­æ³•åˆ†æã€‚é¦–å…ˆæ¥å®šä¹‰ type ç‰ˆçš„è¡¨è¾¾å¼ç±»å‹ã€‚å…¶ä¸­ `ExprType`, `IExpr` å’Œ `ValueType`ï¼Œ äºŒè€…æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚å¯ç›´æ¥çœ‹ ts ç‰ˆçš„ï¼Œè¿™é‡Œçœç•¥ã€‚
```ts
// `ExprType`, `IExpr` å’Œ `ValueType` çš„å®šä¹‰è¯·ç›´æ¥å‚è€ƒ ts ç‰ˆçš„ã€‚

interface LiteralExpr extends Expr {
    type: 'literal';
    value: ValueType;
}

interface BuildLiteralExpr<T extends ValueType> extends LiteralExpr {
    value: T
}

interface GroupExpr extends Expr {
    type: 'group';
    expression: Expr;
}

interface BuildGroupExpr<E extends Expr> extends GroupExpr {
    expression: E;
}

interface BinaryExpr extends Expr {
    type: 'binary';
    left: Expr;
    operator: Token;
    right: Expr;
}

interface BuildBinaryExpr<
    L extends Expr,
    Op extends Token,
    R extends Expr,
> extends BinaryExpr {
    left: L;
    operator: Op;
    right: R;
}

interface UnaryExpr extends Expr {
    type: 'unary';
    operator: Token;
    expression: Expr;
}

interface BuildUnaryExpr<
    Op extends Token,
    E extends Expr,
> extends UnaryExpr {
    operator: Op;
    expression: E;
}
```

type ç‰ˆå®ç°é€’å½’ä¸‹é™å’Œ ts æ˜¯ä¸€è‡´çš„ã€‚æ‰€ä»¥æˆ‘ä»¬ç›´æ¥ä¸Šæ‰‹å®ç°å®Œæ•´ç‰ˆï¼š
```ts
// è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ç”±ä½åˆ°é«˜ï¼š
// logic or:    ||                  å·¦ç»“åˆ
// logic and:   &&                  å·¦ç»“åˆ
// equality:    == !=               å·¦ç»“åˆ
// relation:    < > <= >=           å·¦ç»“åˆ
// additive:    + -                 å·¦ç»“åˆ
// factor:      * / %               å·¦ç»“åˆ
// unary:       !                   å³ç»“åˆ
// primary:     literal group
```

æˆ‘ä»¬å…ˆæ¥çœ‹æ¶å­ä»£ç ï¼š
```ts
// ä¾ç„¶éœ€è¦ result åŒ…è£…å·¥å…·å‡½æ•°ã€‚
type ParseExprError<M extends string> =
    ErrorResult<`[ParseExprError]: ${M}`>;
type ParseExprSuccess<
    R extends Expr,
    T extends Token[],
> = SuccessResult<{ expr: R, rest: T }>;

// Parser çš„å…¥å£æ–¹æ³•ï¼Œå®ƒè¿”å› AST.
type Parse<Tokens extends Token[]> = ParseExpr<Tokens>;

type ParseExpr<Tokens extends Token[]> = ParseLogicOr<Tokens>;

// ...
```

æŒ‰é¡ºåºï¼Œé¦–å…ˆå®ç° `ParseLogicOr`ã€‚æˆ‘ä»¬æŠŠ ts ç‰ˆæœ¬çš„ä»£ç è´´åœ¨æ—è¾¹æ¥ç¿»è¯‘ï¼š
```ts
// ts ç‰ˆæœ¬ä»£ç ï¼Œä½œä¸ºç¿»è¯‘å¯¹ç…§ã€‚
class Parser {
    // ...

    private logicOr() {
        let expr: IExpr = this.logicAnd();
        while (this.match('||')) {
            const operator = this.previous();
            const right = this.logicAnd();
            expr = new BinaryExpr(expr, operator, right);
        }
        return expr;
    }

    // ...
}
```

ç¿»è¯‘ä¸º type ç‰ˆæœ¬ï¼š
```ts
type ParseLogicOr<Tokens extends Token[], R = ParseLogicAnd<Tokens>> =
    R extends ParseExprSuccess<infer Left, infer Rest>
        ? ParseLogicOrBody<Left, Rest>
        : R; // error
type ParseLogicOrBody<Left extends Expr, Tokens extends Token[]> =
    Tokens extends Match<infer Op extends TokenLike<'||'>, infer Rest>
        ? ParseLogicAnd<Rest> extends ParseExprSuccess<infer Right, infer Rest>
            ? ParseLogicOrBody<BuildBinaryExpr<Left, Op, Right>, Rest>
            : ParseExprError<`Parse logic *or* of right fail: ${Rest[0]['lexeme']}`>
        : ParseExprSuccess<Left, Tokens>;
```
è¿™é‡Œä¸ºäº†é¿å…å‡½æ•°è¿‡é•¿å·²ç»ç¼©è¿›è¿‡æ·±ï¼Œå¤šå‡ºæ¥ä¸€ä¸ªè¾…åŠ©å‡½æ•°ã€‚å¦å¤–å°† `R = ParseLogicAnd<Tokens>` åˆ©ç”¨å‡½æ•°é»˜è®¤å‚æ•°æ˜¯ä¸ºäº†æ–¹ä¾¿ï¼Œå‡½æ•°å†…éƒ¨äº§ç”Ÿå±€éƒ¨å¸¸é‡è¦éº»çƒ¦ä¸€äº›:
```ts
type ParseLogicOr<Tokens extends Token[]> =
    ParseLogicAnd<Tokens> extends infer R ?
        R extends ParseExprSuccess<infer Left, infer Rest>
            ? ParseLogicOrBody<Left, Rest>
            : R // error
        : NoWay<'ParseLogicAnd'>; // è¿™é‡Œç”¨ NoWay æ›¿ä»£ never.
```
å¦‚æœä¸ç”¨é»˜è®¤å‚æ•°ï¼Œç¼©è¿›ä¼šæ·±ä¸€äº›ï¼Œå› ä¸ºå¤šäº†ä¸€ä¸ªæ— ç”¨çš„åˆ†æ”¯ã€‚è¿™é‡Œ `NoWay` æ›¿ä»£ `never` æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå¦‚æœä½ å†™çš„ä»£ç æœ‰é—®é¢˜ï¼Œç»“æœè¿”å›äº†ä¸€ä¸ª never ...... å½“ä»£ç é‡å¤§æ—¶ï¼Œä½ ä¸çŸ¥é“è¿”å›çš„ `never` æ˜¯å“ªé‡Œäº§ç”Ÿçš„ï¼åˆ«é—®æˆ‘æ˜¯æ€ä¹ˆçŸ¥é“çš„â€¦â€¦æˆ‘ä¸æƒ³å‹¾èµ·é‚£ç—›è‹¦çš„è°ƒè¯•å›å¿†ã€‚

é‚£æˆ‘ä»¬ä¸ºä»€ä¹ˆä¸ä¸è¿™æ ·å†™å‘¢ï¼Ÿ
```ts
type ParseLogicOr<Tokens extends Token[]> =
    ParseLogicAnd<Tokens> extends ParseExprSuccess<infer Left, infer Rest>
        ? ParseLogicOrBody<Left, Rest>
        : ParseExprError<'ParseLogicOr'>; // error

// æˆ–è€…

type ParseLogicOr<Tokens extends Token[]> =
    ParseLogicAnd<Tokens> extends ParseExprSuccess<infer Left, infer Rest>
        ? ParseLogicOrBody<Left, Rest>
        : ParseLogicAnd<Tokens>; // error
```
ç¬¬ä¸€ä¸ªå†™æ³•ï¼Œå¤–ç•Œæ— æ³•å¾—åˆ°åº•å±‚çš„é”™è¯¯ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸å¤ªå¥½çš„ã€‚æˆ‘ä»¬çš„è§£é‡Šå™¨è™½ç„¶æ²¡æœ‰æä¾›è¯¦å°½çš„é”™è¯¯ä¿¡æ¯ï¼ˆæ¯”å¦‚è¡Œå·ç­‰ï¼‰ï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½è¯´çš„å¤ªæ¨¡ç³Šã€‚ç›´æ¥å°†åº•å±‚çš„é”™è¯¯æŠ›å‡ºï¼Œé¿å…äº†é”™è¯¯ä¿¡æ¯è¶Šæ¥è¶Šæ¨¡ç³Šã€‚ç¬¬äºŒä¸ªé€»è¾‘ä¸Šæ˜¯OKçš„ã€‚ä½†æ˜¯ç›´è§‚ä¸Šä¼šè®© ts çš„ç¼–è¯‘å™¨åšæ›´å¤šçš„äº‹ã€‚æˆ‘ä¸å¤ªç¡®å®š ts çš„ç¼–è¯‘å™¨æœ‰æ²¡æœ‰å¯¹è¿™ä¸ªæƒ…å†µåšä¼˜åŒ–ã€‚å¦‚æœæœ‰çš„è¯å°±æ˜¯æˆ‘å¤šè™‘äº†ã€‚æ‰€ä»¥æˆ‘è¿˜æ˜¯ä¿å®ˆçš„é€‰æ‹©äº†å‡½æ•°é»˜è®¤å‚æ•°æˆ–è€…å±€éƒ¨å¸¸é‡çš„æ–¹å¼ã€‚

é¢ï¼Œå·®ç‚¹å¿˜è®°äº†ã€‚è¿˜æœ‰å·¥å…·å‡½æ•°ï¼š
```ts
type OpOrKeywordTokenType = Exclude<TokenType, 'number' | 'identifier' | 'EOF'>

type TokenLike<T extends OpOrKeywordTokenType | Partial<Token>> =
    T extends OpOrKeywordTokenType
        ? BuildToken<T, T>
        : T extends Partial<Token>
            ? Token & T
            : never;

type Match<T, R extends Token[]> = [T, ...R];
```

å‰©ä¸‹çš„äºŒå…ƒæ“ä½œè§£æä»£ç ï¼Œæˆ‘æƒ³æˆ‘ä¸ç”¨è¯´äº†ã€‚æˆ‘ä»¬ç›´æ¥æ¥çœ‹ `unary` å’Œ `primary` çš„ä»£ç å§ï¼š
```ts
type ParseUnary<Tokens extends Token[]> =
    Tokens extends Match<infer Op extends TokenLike<'!'>, infer Rest>
        ? ParseUnary<Rest> extends ParseExprSuccess<infer Expr, infer Rest>
            ? ParseExprSuccess<BuildUnaryExpr<Op, Expr>, Rest>
            : ParseExprError<`ParseUnary error after ${Op["lexeme"]}`>
        : ParsePrimary<Tokens>;

type ParsePrimary<Tokens extends Token[]> =
    Tokens extends Match<infer E extends Token, infer R>
        ? E extends { type: 'number', value: infer V extends number }
            ? ParseExprSuccess<BuildLiteralExpr<V>, R>
            : E extends { type: 'string', lexeme: infer V extends string }
                ? ParseExprSuccess<BuildLiteralExpr<V>, R>
                : E extends { type: infer B extends keyof Keywords }
                    ? ParseExprSuccess<BuildLiteralExpr<ToValue<B>>, R>
                    : E extends TokenLike<'('>
                        ? ParseExpr<R> extends ParseExprSuccess<infer G, infer RG>
                            ? RG extends Match<TokenLike<')'>, infer Rest>
                                ? ParseExprSuccess<BuildGroupExpr<G>, Rest>
                                : ParseExprError<`Group not match ')'.`>
                            : ParseExprError<`Parse Group expression fail.`>
                        : ParseExprError<`Unknown token type: ${E['type']}, lexeme: ${E['lexeme']}`>
        : ParseExprError<`ParsePrimary fail`>;

type ToValue<K extends keyof Keywords> = Safe<
    KeywordValueMapping[Safe<K, keyof KeywordValueMapping>],
    ValueType>;

type KeywordValueMapping = {
    true: true;
    false: false;
    null: null;
};
```
ä¸Šé¢è§£æ `group` çš„é‚£æ®µä»£ç ï¼Œä½ åº”è¯¥æ„Ÿå—åˆ°äº†ï¼Œè¯­è¨€ç‰¹æ€§è´«ç˜ å¸¦æ¥çš„ä»£ç å†—é•¿ã€‚è¿™æ˜¯æ²¡åŠæ³•çš„äº‹æƒ…ã€‚åé¢ä½ ä¼šä¹ æƒ¯çš„ğŸ˜‚ã€‚

å¥½äº†ï¼Œä»¥ä¸Šå°±æ˜¯æˆ‘ä»¬è¯­æ³•åˆ†æè¡¨è¾¾å¼çš„å…¨éƒ¨äº†ï¼Œå®Œæ•´çš„ä»£ç è§ [type-ParseExpr](https://github.com/huanguolin/toc/blob/master/type-toc/parser/ParseExprHelper.d.ts#L13)ã€‚å…³äº `var` è¯­å¥, `if` è¯­å¥, `block` è¯­å¥, å‡½æ•°, `for` å¾ªç¯è¯­å¥ç­‰ç‰¹æ€§ï¼Œæˆ‘ä»¬ä¼šåœ¨æ‰“é€š `æ‰§è¡Œ` ä¸€å…³åï¼Œæ…¢æ…¢åŠ ä¸Šçš„ã€‚æˆ‘ä»¬å·²ç»å•ƒäº†è¯­æ³•åˆ†ææœ€æ ¸å¿ƒçš„éƒ¨åˆ†äº†ã€‚åç»­æˆ–è®¸ä»£ç ä¼šæ›´å¤šï¼Œæ ¸å¿ƒâ€œç§‘æŠ€â€å´æ²¡å¤šå¤šå°‘ã€‚


#### 2.2.4 æ‰§è¡Œ
ç»ˆäºåˆ°æœ€åä¸€ä¸ªé˜¶æ®µäº†ã€‚å®Œæˆå®ƒï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„è§£é‡Šå™¨ï¼Œè™½ç„¶æš‚æ—¶åªèƒ½æ”¯æŒè¡¨è¾¾å¼ï¼Œä½†è¿™å·²ç»åšå‡ºäº†å¾ˆå¤§æˆæœã€‚

å¦‚ä½ æ‰€æ–™ï¼Œè¿™é‡Œå¹¶ä¸éš¾ã€‚ä¸è¿‡æˆ‘ä»¬è¿˜ä¸èƒ½é©¬ä¸Šå¼€å§‹ ts ç‰ˆçš„æ‰§è¡Œå™¨ã€‚å‰é¢è¯´è¿‡ï¼Œts ç‰ˆè¦ç”¨æœ€è‡ªç„¶çš„æ–¹å¼ã€‚ä½¿ç”¨é¢å‘å¯¹è±¡æ¥æ“ä½œ ASTï¼Œæ˜¯ä¸€ä¸ªè‘—åè®¾è®¡æ¨¡å¼çš„ç»å…¸åº”ç”¨åœºæ™¯ã€‚å¦‚æœä½ çŸ¥é“ [å¦‚ä½•ä¿®æ”¹C#çš„è¡¨è¾¾å¼æ ‘](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees#:~:text=You%20can%20use%20the%20ExpressionVisitor%20class%20to%20traverse%20an%20existing%20expression%20tree%20and%20to%20copy%20each%20node%20that%20it%20visits.)ï¼Œæˆ–è€…ä½ æŠŠç©è¿‡ [Roslyn](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/), ä½ ä¸€å®šè§è¿‡åƒ [SymbolVisitor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.symbolvisitor?view=roslyn-dotnet-4.3.0) ç±»ä¸­çš„é‚£äº› `Visit` å¼€å¤´çš„ `API`ã€‚æ²¡é”™ï¼Œæˆ‘è¯´çš„å°±æ˜¯è®¿é—®è€…æ¨¡å¼ã€‚ä½¿ç”¨å®ƒï¼Œè¿™é‡Œæ‰æ›´â€œè‡ªç„¶â€ï¼Œæˆ–è€…â€œå¯¹å‘³â€ã€‚

##### 2.2.4.1 è®¿é—®è€…æ¨¡å¼ä¸ts-Interpreter

å¦‚æœæˆ‘ä»¬ç›´æ¥å¼€å§‹æˆ‘ä»¬çš„æ‰§è¡Œå™¨ä»£ç ï¼Œæˆ‘ä»¬å¯èƒ½å†™å‡ºå¦‚ä¸‹çš„ä»£ç ï¼š
```ts
if (expr instanceof BinaryExpr) {
    // ...
} else if (expr instanceof UnaryExpr) {
    // ...
} else if // ...

// æˆ–è€…

switch (expr.type) {
    case 'binary':
        // ...
    case 'unary':
        // ...
}

// åˆæˆ–è€…æˆ‘ä»¬ç›´æ¥å°†å¯¹åº”çš„æ“ä½œæ·»åŠ åœ¨å¯¹åº”çš„ç±»ä¸­ï¼š
class UnaryExpr implements IExpr {
    type: ExprType = 'unary';
    operator: Token;
    expression: IExpr;

    constructor(operator: Token, expr: IExpr) {
        this.operator = operator;
        this.expression = expr;
    }

    interpret() {
        // ...
    }
}
```
è¯šç„¶ï¼Œè¿™æ ·çš„ä»£ç æ˜¯å¯ä»¥å·¥ä½œçš„ã€‚ä½†éƒ½ä¸å¤Ÿä¼˜é›…æˆ–è€…çµæ´»ã€‚æˆ‘ä»¬çš„è§£é‡Šå™¨åªæœ‰ä¸‰æ­¥ï¼šè¯æ³•åˆ†æï¼Œè¯­æ³•åˆ†æï¼Œæ‰§è¡Œã€‚å‡å¦‚æˆ‘ä»¬æœªæ¥å¢åŠ äº†é™æ€æ£€æŸ¥çš„éƒ¨åˆ†ã€‚ä¸€èˆ¬æ˜¯å¢åŠ ä¸€æ­¥ï¼Œæ”¾åœ¨è¯­æ³•åˆ†æä¸æ‰§è¡Œä¹‹é—´ã€‚å¦‚æœæ˜¯ä½¿ç”¨ä¸Šé¢å‰ä¸¤ç§çš„åšæ³•ï¼Œåªéœ€è¦æ–°å†™ä¸€ä¸ªç±»ï¼Œä½†å†—é•¿çš„ `if-else` æˆ–è€… `switch` è¯­å¥åˆè¦æ¥ä¸€éï¼Ÿå¦‚æœæ˜¯æœ€åä¸€ç§å†™æ³•ï¼Œé‚£æˆ‘ä»¬ä¸å¾—ä¸ä¿®æ”¹æ¯ä¸ª `Expr` ç±»ï¼Œä¸ºå®ƒæ–°æ·»åŠ ä¸€ä¸ªæ–¹æ³•ã€‚æˆ–è®¸ä½ è§‰çš„è¿™å¯ä»¥æ¥å—ï¼Œä½†æ˜¯è®©ä¸€ç±»æ“ä½œï¼Œåˆ†æ•£åœ¨å„ä¸ªåœ°æ–¹ã€‚ç‰¹åˆ«æ˜¯è¿™ç§ç±»æœ‰å¤šè¾¾å‡ åä¸Šç™¾ï¼Œç”šè‡³ä¸Šåƒæ—¶ï¼Œç»´æŠ¤èµ·æ¥æ˜¯å¾ˆå¤´ç–¼çš„ã€‚

é‚£æˆ‘ä»¬æ¥çœ‹çœ‹è®¿é—®è€…æ¨¡å¼æ˜¯å¦‚ä½•è§£å†³è¿™äº›é—®é¢˜ï¼š

é¦–å…ˆæˆ‘ä»¬è¦æ–°å¢ä¸€ä¸ªæ¥å£ï¼Œå¹¶ç»™ `IExpr` æ·»åŠ ä¸€ä¸ªæ–¹æ³•ï¼š
```ts
interface IExprVisitor<T> {
    visitBinaryExpr: (expr: BinaryExpr) => T;
    visitGroupExpr: (expr: GroupExpr) => T;
    visitUnaryExpr: (expr: UnaryExpr) => T;
    visitLiteralExpr: (expr: LiteralExpr) => T;
}

interface IExpr {
    type: ExprType;

    // æ–°å¢ accept æ–¹æ³•
    accept: <R>(visitor: IExprVisitor<R>) => R;
}
```

ç„¶åè¡¨è¾¾å¼ç±»éœ€è¦å®ç°è¿™äº› `accept` æ–¹æ³•ï¼š
```ts
class LiteralExpr implements IExpr {
    // å…¶ä»–ä»£ç çœç•¥â€¦â€¦
    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitLiteralExpr(this);
    }
}

class UnaryExpr implements IExpr {
    // å…¶ä»–ä»£ç çœç•¥â€¦â€¦
    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitUnaryExpr(this);
    }
}

class BinaryExpr implements IExpr {
    // å…¶ä»–ä»£ç çœç•¥â€¦â€¦
    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitBinaryExpr(this);
    }
}

class GroupExpr implements IExpr {
    // å…¶ä»–ä»£ç çœç•¥â€¦â€¦
    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitGroupExpr(this);
    }
}
```
æ¯ä¸ªåªéœ€è¦è°ƒç”¨ä¸è‡ªå·±å¯¹åº”çš„é‚£ä¸ªæ–¹æ³•å³å¯ã€‚æ˜¯ä¸æ˜¯å¾ˆå®¹æ˜“ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬å°±èƒ½å®ç° `Interpreter` ç±»äº†ï¼š
```ts
class Interpreter implements IExprVisitor<unknown> {

    interpret(expr: IExpr): ValueType {
        return expr.accept(this);
    }

    visitLiteralExpr(expr: LiteralExpr): ValueType {
        return expr.value;
    }

    visitGroupExpr(expr: GroupExpr): ValueType {
        return expr.expression.accept(this);
    }

    visitUnaryExpr(expr: UnaryExpr): boolean {
        const v = expr.expression.accept(this);
        if (expr.operator.type === '!') {
            return !v;
        }
        throw new RuntimeError('Unknown unary operator: ' + expr.operator.type);
    }

    visitBinaryExpr(expr: BinaryExpr): ValueType {
        // TODO
    }
}
```
ç®€ç›´ä¸æ•¢ç›¸ä¿¡ï¼Œç°åœ¨ï¼Œåªè¦å®Œæˆ `visitBinaryExpr` å‡½æ•°ï¼Œå°±å®Œå·¥äº†ï¼

åœ¨å®Œæˆå®ƒä¹‹å‰ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹è®¿é—®è€…æ¨¡å¼æ˜¯æ€ä¹ˆåšåˆ°çš„ã€‚æˆ‘ä»¬çœ‹çœ‹å¦‚æœæˆ‘é€‰æ‹©ç”¨ `switch` æ¥å¹²è¿™ä¸ªäº‹æƒ…ï¼š
```ts
class Interpreter {

    interpret(expr: IExpr): ValueType {
        return this.evalExpr(expr);
    }

    evalExpr(expr: IExpr): ValueType {
        switch (expr.type) {
            case 'literal': return this.evalLiteralExpr(expr as LiteralExpr);
            case 'group': return this.evalGroupExpr(expr as GroupExpr);
            case 'unary': return this.evalUnaryExpr(expr as UnaryExpr);
            case 'binary': return this.evalBinaryExpr(expr as BinaryExpr);
            default:
                throw new RuntimeError('Unknown expr type: ' + expr.type);
        }
    }

    evalLiteralExpr(expr: LiteralExpr): ValueType {
        return expr.value;
    }

    evalGroupExpr(expr: GroupExpr): ValueType {
        return this.evalExpr(expr.expression);
    }

    evalUnaryExpr(expr: UnaryExpr): boolean {
        const v = this.evalExpr(expr.expression);
        if (expr.operator.type === '!') {
            return !v;
        }
        throw new RuntimeError('Unknown unary operator: ' + expr.operator.type);
    }

    evalBinaryExpr(expr: BinaryExpr): ValueType {
        // TODO
    }
}
```

æˆ–è®¸ä½ ä¼šè§‰å¾—è¿™æ ·å†™ä¹Ÿå¾ˆå¥½å•Šï¼Œè‡³å°‘å¥½ç†è§£ã€‚å¥½ç†è§£çš„ç¡®æ˜¯ä¼˜ç‚¹ã€‚ä½†éšç€è¡¨è¾¾å¼ç§ç±»å¢å¤šï¼Œ`switch` çš„ `case` ä¼šè¶Šæ¥è¶Šé•¿ã€‚å‡å¦‚ç°åœ¨è¦å®ç°ä¸€ä¸ª `Resolve` ç±»ï¼Œå®ƒèƒ½åšé™æ€æ£€æŸ¥ï¼ˆæ¯”å¦‚åé¢åŠ äº†å˜é‡ï¼Œè¿™é‡Œå¯ä»¥æ£€æŸ¥å˜é‡åœ¨ä½¿ç”¨æ—¶æœ‰æ²¡æœ‰å®šä¹‰ï¼‰ã€‚è¿™æ ·å†™çš„è¯ `switch` ä»£ç ä¼šå†æ¥ä¸€éã€‚ä½†æ˜¯è®¿é—®è€…æ¨¡å¼å°±å…å»äº†è¿™ä¸ªéƒ¨åˆ†ã€‚è¿™æ ·å¯¹æ¯”çš„è¯ï¼Œè®¿é—®è€…æ¨¡å¼å®ç°äº†ç‰¹å®šçš„ `Expr` ç±»å‹ä¼šâ€œè‡ªåŠ¨â€è°ƒç”¨ä¸ä¹‹é…å¯¹çš„æ–¹æ³•ã€‚å“ˆå“ˆï¼Œè‡ªåŠ¨ï¼Ÿå®é™…ä¸Šæ˜¯æ¯ä¸ª `Expr` ç±»å‹çš„ `accept` æ–¹æ³•ä¸­è°ƒç”¨äº†é‚£ä¸ªå¯¹åº”çš„æ–¹æ³•ã€‚

æˆ‘æƒ³ä½ å·²ç» `get` äº†è®¿é—®è€…æ¨¡å¼çš„ç¾å¦™ï¼Œç°åœ¨æ˜¯æ—¶å€™æ¥å®Œæˆ `visitBinaryExpr` æ–¹æ³•äº†ã€‚
```ts
class Interpreter implements IExprVisitor<unknown> {
    // ...

    visitBinaryExpr(expr: BinaryExpr): ValueType {
        const operator = expr.operator;

        const leftValue = expr.left.accept(this);
        // && || éœ€è¦è€ƒè™‘çŸ­è·¯
        if (operator.type == '&&') {
            return leftValue && expr.right.accept(this);
        } else if (operator.type == '||') {
            return leftValue || expr.right.accept(this);
        } else {
            // ä¸éœ€è¦è€ƒè™‘çŸ­è·¯çš„ï¼Œå¯ç›´æ¥æ±‚å‡ºå³å€¼
            const rightValue = expr.right.accept(this);
            if (operator.type == '+') {
                if (this.isString(leftValue) && this.isString(rightValue)) {
                    return leftValue + rightValue;
                } else if (this.isNumber(leftValue) && this.isNumber(rightValue)) {
                    return leftValue + rightValue;
                }
                throw new RuntimeError('"+" operator only support both operand is string or number.');
            } else if (operator.type == '==') {
                return leftValue == rightValue;
            } else if (operator.type == '!=') {
                 return leftValue != rightValue;
            } else {
                // çº¯æ•°å­—è¿ç®—
                if (this.isNumber(leftValue) && this.isNumber(rightValue)) {
                    return this.evalMath(operator.type, leftValue, rightValue);
                }
                throw new RuntimeError(`Required both operand is number for operator ${operator.type}: left=${leftValue}, right=${rightValue}`);
            }
        }
    }
}
```
ä¸Šé¢ç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ï¼Œ`&&` å’Œ `||` å…·æœ‰çŸ­è·¯æ•ˆæœï¼Œä¸èƒ½å…ˆæŠŠå³æ“ä½œæ•°æ±‚å‡ºæ¥ã€‚ç›®å‰ä½ è¿˜æ„Ÿè§‰ä¸åˆ°å·®å¼‚ï¼Œæœ‰äº†å˜é‡å’Œå‡½æ•°ä¹‹åï¼Œå°±å¯ä»¥çœ‹åˆ°æ•ˆæœäº†ã€‚å¦å¤–ä¸€ä¸ªè¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬çš„ `+` å¯ä»¥æ”¯æŒå­—ç¬¦ä¸²è¿æ¥å’Œæ•°å­—ç›¸åŠ ï¼Œè¦åˆ†åˆ«å¤„ç†ï¼Œä½†æ˜¯ä¸å…è®¸æ··åˆã€‚å®Œæ•´çš„ä»£ç è§ [ts-Interpreter](https://github.com/huanguolin/toc/blob/master/ts-toc/Interpreter/index.ts);

æˆ‘ä»¬åšå®Œäº†å—ï¼Ÿå®é™…ä¸Šè¿˜å·®ä¸€æ­¥ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰æŠŠ `Scanner`, `Parser` å’Œ `Interpreter` ç»„åˆåˆ°ä¸€èµ·ã€‚å¦‚æœæ˜¯ `node.js` ç¯å¢ƒï¼Œå¯ä»¥å†™ä¸€ä¸ª `REPL`([Readâ€“evalâ€“print loop](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop))ï¼š
```ts
import { Interpreter } from './Interpreter';
import { Parser } from './Parser';
import { Scanner } from './Scanner';

const readline = require('readline');
const interpreter = new Interpreter();

main();

function main() {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    process.stdout.write('> ');
    rl.on('line', function (line) {
        try {
            console.log('=', toc(line));
        } catch (e) {
            let errMsg = e;
            if (e instanceof Error) {
                errMsg = e.message;
            }
            console.error('Error: ', errMsg);
        }
        process.stdout.write('> ');
    });
}

function toc(source: string) {
    const scanner = new Scanner(source);
    const parser = new Parser(scanner.scan());
    return interpreter.interpret(parser.parse());
}
```

å¥½äº†ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªå¯ä»¥æ‰§è¡Œ `toc` ç¨‹åºçš„ç¨‹åºã€‚ä½ å¯ä»¥è¾“å…¥ä¸€æ®µä»£ç ï¼Œå¹¶æŸ¥çœ‹è¾“å‡ºäº†ğŸ˜„ã€‚

##### 2.2.4.2 type-Interpreter

æ¥ä¸‹æ¥å®ç°æˆ‘ä»¬çš„ type ç‰ˆæœ¬ã€‚ä½†æ˜¯è¿™é‡Œæ²¡æ³•å®ç°è®¿é—®è€…æ¨¡å¼ï¼Œç”šè‡³æ²¡æœ‰ `switch` å¯ç”¨ã€‚æˆ‘ä»¬åªèƒ½ç”¨ç±»ä¼¼ `if-elseif` ä¸€èˆ¬çš„æ¡ä»¶åˆ¤æ–­æ¥å®ç°ï¼š
```ts
type Interpret<E extends Expr> = InterpretExpr<E>;

type InterpretExpr<E extends Expr> =
    E extends LiteralExpr
        ? InterpretExprSuccess<E['value']>
        : E extends GroupExpr
            ? InterpretExpr<E['expression']>
            : E extends UnaryExpr
                ? EvalUnaryExpr<E>
                : E extends BinaryExpr
                    ? EvalBinaryExpr<E>
                    : RuntimeError<`Unknown expression type: ${E['type']}`>;

type RuntimeError<M extends string> = ErrorResult<`[RuntimeError]: ${M}`>;
type InterpretExprSuccess<Value extends ValueType > = SuccessResult<{ value: Value }>;
```
é€šè¿‡å‚è€ƒ ts ç‰ˆæœ¬ï¼Œå®ç° type ä¹Ÿä¸éš¾ã€‚è€Œä¸”å¯¹äº `LiteralExpr` å’Œ `GroupExpr` çš„æ‰§è¡Œï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰å¦èµ·å‡½æ•°ï¼Œç›´æ¥å°±è¿”å›ç»“æœäº†ã€‚ç°åœ¨åªå‰©ä¸‹ `UnaryExpr` å’Œ `BinaryExpr`ã€‚æˆ‘ä»¬å…ˆçœ‹ `EvalUnaryExpr`:
```ts
type EvalUnaryExpr<
    E extends UnaryExpr,
    Op extends TokenType = E['operator']['type'],
    V = InterpretExpr<E['expression']>
> = Op extends '!'
    ? V extends InterpretExprSuccess<infer Val>
        ? InterpretExprSuccess<Inverse<Val>>
        : V // error
    : RuntimeError<`Unknown unary operator: ${Op}`>;

type Inverse<T> = IsFalse<T>;

// åˆ¤æ–­çœŸå€¼ï¼Œå‡å€¼å’Œ js ä¸€è‡´ã€‚
type IsFalse<T> =
    T extends false | null | undefined | 0 | ''
        ? true
        : T extends string
            ? TrimStart<T> extends ''
                ? true
                : false
            : false;
```

æœ€åæ˜¯ `EvalBinaryExpr`ï¼Œå®ƒæ¯”è¾ƒéº»çƒ¦ï¼Œä½†ä¹Ÿåªæ˜¯æŒ‰ç…§æ“ä½œç¬¦ç±»å‹æ¥è°ƒç”¨å…·ä½“çš„å®ç°å‡½æ•°ã€‚
```ts
type EvalBinaryExpr<
    E extends BinaryExpr,
    Op extends TokenType = E['operator']['type'],
    LR = InterpretExpr<E['left']>,
    Right extends Expr = E['right'], // ä¸èƒ½ç›´æ¥æ±‚å€¼ Right, å› ä¸º && || æœ‰çŸ­è·¯çš„æ•ˆæœã€‚
> =
    LR extends InterpretExprSuccess<infer LV>
        ? Op extends '==' | '!='
            ? EvalEquality<Op, LV, InterpretExpr<Right>>
            : Op extends '&&' | '||'
                ? EvalLogicAndOr<Op, LV, Right>
                : EvalRestBinaryExpr<Op, LV, InterpretExpr<Right>>
        : LR; // error


type EvalLogicAndOr<
    Op extends '&&' | '||',
    LV extends ValueType,
    Right extends Expr,
> = Op extends '&&'
    ? IsTrue<LV> extends true
        ? InterpretExpr<Right>
        : InterpretExprSuccess<LV>
    : Op extends '||'
        ? IsTrue<LV> extends true
            ? InterpretExprSuccess<LV>
            : InterpretExpr<Right>
        : RuntimeError<`EvalLogicAndOr fail when meet: ${Op}`>;


type EvalEquality<
    Op extends '==' | '!=',
    LV extends ValueType,
    RR,
> = RR extends InterpretExprSuccess<infer RV>
    ? Op extends '=='
        ? InterpretExprSuccess<Eq<LV, RV>>
        : Op extends '!='
            ? InterpretExprSuccess<Inverse<Eq<LV, RV>>>
            : RuntimeError<`EvalEquality fail when meet: ${Op}`>
    : RR; // error

type EvalRestBinaryExpr<
    Op extends TokenType,
    LV extends ValueType,
    RR,
> = RR extends InterpretExprSuccess<infer RV>
    ? Op extends '+'
        ? [LV, RV] extends IsNumbers<infer N1, infer N2>
            ? WrapBinaryResult<Add<N1, N2>>
            : [LV, RV] extends IsStrings<infer N1, infer N2>
                ? WrapBinaryResult<`${N1}${N2}`>
                : RuntimeError<'"+" operator only support both operand is string or number.'>
        : [LV, RV] extends IsNumbers<infer N1, infer N2>
            ? EvalMath<Op, N1, N2>
            : RuntimeError<`EvalRestBinaryExpr fail, Left or Right is not a number: left:${ExtractError<LV>}, right:${ExtractError<RR>}`>
    : RR; // error

type EvalMath<
    Op extends TokenType,
    N1 extends number,
    N2 extends number,
> = Op extends '-'
    ? WrapBinaryResult<Sub<N1, N2>>
    : Op extends '*'
        ? WrapBinaryResult<Mul<N1, N2>>
        : Op extends '/'
            ? WrapBinaryResult<Div<N1, N2>>
            : Op extends '%'
                ? WrapBinaryResult<Mod<N1, N2>>
                : Op extends '<'
                    ? WrapBinaryResult<Lt<N1, N2>>
                    : Op extends '>'
                        ? WrapBinaryResult<Gt<N1, N2>>
                        : Op extends '<='
                            ? WrapBinaryResult<Lte<N1, N2>>
                            : Op extends '>='
                                ? WrapBinaryResult<Gte<N1, N2>>
                                : RuntimeError<`Unknown binary operator: ${Op}`>;

type WrapBinaryResult<V> =
    V extends ValueType
        ? InterpretExprSuccess<V>
        : ExtractError<V>;

type ExtractError<E> =
    E extends { error: infer M extends string }
        ? M
        : Safe<E, string | number | boolean | null | undefined>;

type IsStrings<N1 extends string, N2 extends string> = [N1, N2];
type IsNumbers<N1 extends number, N2 extends number> = [N1, N2];
```

è™½ç„¶å¾ˆéº»çƒ¦ã€‚ä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯åšåˆ°äº†ï¼ç°åœ¨æŠŠ `Scan`, `Parse` å’Œ `Interpret` ä¸²èµ·æ¥å°±å¤§åŠŸå‘Šæˆäº†! ä½†æ˜¯å¹¶ä¸æ˜¯ä½ æƒ³çš„é‚£æ ·ä¸²èµ·æ¥ï¼š
```ts
type Toc<Source extends string> =
    Scan<Source> extends infer Tokens
        ? Tokens extends Token[]
            ? Parse<Tokens> extends infer Ast
                ? Interpret<Ast> extends infer Value
                    ? Value
                    : NoWay<'Toc-Interprets'>
                : NoWay<'Toc-Parse'>
            : Tokens // error
        : NoWay<'Toc-Scan'>;
```
ä¸ºä»€ä¹ˆä¸æ˜¯ `type Toc<S extend string> = Interpret<Parse<Scan<S>>>` ? å› ä¸ºé”™è¯¯æ— æ³•å±•ç¤ºå‡ºæ¥ã€‚ts ä¸­æœ‰å¼‚å¸¸æœºåˆ¶ï¼Œæœ‰é”™è¯¯æŠ›å‡ºæ¥å¤–é¢å¯ä»¥æ•è·ã€‚è¿™é‡Œæ²¡æœ‰å¼‚å¸¸ï¼Œé”™è¯¯åªèƒ½ç”¨å‡½æ•°è¿”å›å€¼å±‚å±‚ä¼ é€’å‡ºå»ã€‚

å¥½äº†ï¼Œæˆ‘ä»¬æœ€ç»ˆè¿˜æ˜¯å¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„ [type-Interpreter](https://github.com/huanguolin/toc/blob/master/type-toc/interpreter/index.d.ts)ã€‚

ç°åœ¨ç»ˆäºä» 0 åˆ° 1 äº†ã€‚è¿‡ç¨‹æˆ–è®¸è‰°éš¾ç—›è‹¦ï¼Œä½†æ˜¯ç»“æœç”šæ˜¯å–œäººâ€”â€”æˆ‘ä»¬é¢„æœŸçš„éƒ½å®ç°äº†ã€‚ä¹ŸéªŒè¯äº† ts ç±»å‹ç³»ç»Ÿæ˜¯å›¾çµå®Œå¤‡çš„ã€‚åé¢æˆ‘ä»¬è¿˜ä¼šç»§ç»­â€œæ”€ç™»â€ä¸€ä¸ªä¸€ä¸ªçš„â€œå°å±±å³°â€ï¼Œä½ ä¼šçœ‹åˆ°åœ¨è¿™ä¸ªâ€œè´«ç˜ â€çš„è¯­è¨€åœŸå£¤ä¸‹ï¼Œä¹Ÿå¯ä»¥ç»“å‡ºä¸°ç¡•çš„â€œç‰¹æ€§â€æœå®ã€‚


#### 2.2.5 è¯­å¥
æˆ‘ä»¬æœ‰äº†è¡¨è¾¾å¼ï¼Œä½†è¿˜æ²¡æœ‰è¯­å¥ã€‚ç°åœ¨å¯ä»¥æ­å»ºæ”¯æŒè¯­å¥çš„â€œä¸–ç•Œâ€äº†ã€‚è¿™é‡Œæœ‰å˜é‡å£°æ˜è¯­å¥ï¼Œæ¡ä»¶è¯­å¥ï¼Œå¾ªç¯è¯­å¥ï¼Œå—è¯­å¥ï¼Œå½“ç„¶è¿˜æœ‰è¡¨è¾¾å¼è¯­å¥ã€‚æˆ‘ä»¬ç”¨ä¸æ”¯æŒå˜é‡å’Œå¾ªç¯çš„è¯­è¨€å¯ä»¥æ‰“é€ æ”¯æŒå˜é‡å’Œå¾ªç¯çš„è¯­è¨€ï¼
æˆ‘ä»¬çš„è¯æ³•åˆ†æå·²ç»åŒ…å«äº†æ•´ä¸ªè¯­è¨€æ‰€éœ€çš„è¯ç´ ã€‚åç»­çš„ç‰¹æ€§æ·»åŠ åªéœ€ä»è¯­æ³•åˆ†æå¼€å§‹ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¯­å¥çš„è¯­æ³•è¡¨è¿°:
```shell
# declarations
declaration    â†’ funDecl
               | varDecl
               | statement ;

funDecl        â†’ "fun" function ;
varDecl        â†’ "var" IDENTIFIER ( "=" expression )? ";" ;

function       â†’ IDENTIFIER "(" parameters? ")" block ;
parameters     â†’ IDENTIFIER ( "," IDENTIFIER )* ;


# statements
statement      â†’ exprStmt
               | forStmt
               | ifStmt
               | block ;

exprStmt       â†’ expression ";" ;
forStmt        â†’ "for" "(" ( varDecl | exprStmt | ";" )
                           expression? ";"
                           expression? ")" statement ;
ifStmt         â†’ "if" "(" expression ")" statement
                 ( "else" statement )? ;
block          â†’ "{" declaration* "}" ;
```
é¢ï¼Œä¸ºä»€ä¹ˆæœ€ä¸Šé¢æ˜¯ `declaration`?
éš¾åˆ°ä¸éƒ½æ˜¯è¯­å¥å—?
éƒ½åˆ’åˆ° `statement` ä¸‹ä¸è¡Œå—ï¼Ÿåƒä¸‹é¢è¿™æ ·ï¼š
```shell
# statements
statement      â†’ funDecl
               | varDecl
               | exprStmt
               | forStmt
               | ifStmt
               | block ;

funDecl        â†’ "fun" function ;
varDecl        â†’ "var" IDENTIFIER ( "=" expression )? ";" ;

function       â†’ IDENTIFIER "(" parameters? ")" block ;
parameters     â†’ IDENTIFIER ( "," IDENTIFIER )* ;

exprStmt       â†’ expression ";" ;
forStmt        â†’ "for" "(" ( varDecl | exprStmt | ";" )
                           expression? ";"
                           expression? ")" statement ;
ifStmt         â†’ "if" "(" expression ")" statement
                 ( "else" statement )? ;
block          â†’ "{" statement* "}" ;

```

æˆ‘å…ˆå›ç­”ç¬¬äºŒä¸ªé—®é¢˜ï¼Œçš„ç¡®ï¼Œä»–ä»¬éƒ½æ˜¯è¯­å¥ã€‚
ç„¶åå›ç­”ç¬¬ä¸‰ä¸ªé—®é¢˜ï¼Œä½œä¸ºè¯­è¨€è®¾è®¡è€…ï¼Œæˆ‘å¯ä»¥å…è®¸è‡ªå·±è®¤ä¸ºå¯è¡Œçš„è¯­æ³•æ–¹æ¡ˆã€‚å¦‚æœæˆ‘æƒ³éƒ½åˆ’åˆ° `statement` ä¸‹ï¼Œé‚£å½“ç„¶ä¹Ÿå¯ä»¥ã€‚å¯æ˜¯è¿™é‡Œæˆ‘ä¸æƒ³ï¼Œå›ç­”äº†æˆ‘ä¸ºä»€ä¹ˆä¸æƒ³ï¼Œä¹Ÿå°±å›ç­”äº†ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚
è¿™ä¸¤ç§æ‰€å…è®¸çš„è¯­æ³•æ˜¯ä¸å¤ªä¸€æ ·çš„ã€‚å¦‚æœéƒ½ç»Ÿä¸€åˆ° `statement` ä¸‹ï¼Œå®ƒå°±å…è®¸ä¸‹é¢çš„å†™æ³•ï¼š
```ts
if (x > 10) var a = 0;
```
è¿™å›é€ æˆä»€ä¹ˆé—®é¢˜å‘¢ï¼Ÿ`a` å®šä¹‰ä¸å¦åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½å¾—çŸ¥ï¼Œå¦‚æœ `x > 10` çš„æ¡ä»¶æˆç«‹ï¼Œåˆ™ `a` å®šä¹‰äº†ï¼Œå¦åˆ™æ˜¯ä¸ºå®šä¹‰ã€‚è¿™æ ·åœ¨è¿™ä¸ªè¯­å¥ä¹‹åï¼Œè®©ä½¿ç”¨å˜é‡ `a` å˜å¾—å¾ˆå›°éš¾ã€‚è¿™ç§é—®é¢˜åŒæ ·å­˜åœ¨äº `for` ä¸ `fun` çš„ç»„åˆï¼š
```ts
for (; false ;) fun test() {}
```
æ‰€ä»¥æˆ‘æ‹’ç»è¿™ç§è®©äººå›°æƒ‘ä¸å·²çš„è¯­æ³•ã€‚æˆ‘ä»¬é€‰å–æœ‰ `declaration` çš„é‚£ä¸€å¥—è¯­æ³•è§„åˆ™ã€‚å®ƒå°†èƒ½äº§ç”Ÿå˜é‡ï¼ˆå‡½æ•°åä¹Ÿæ˜¯å˜é‡å“Ÿï¼‰åˆ’ä¸º `declaration`ï¼Œç„¶åå¯ä»¥é€’å½’ä¸‹é™åˆ° `statement`ã€‚`if`, `for` ç­‰è¯­å¥ä¸‹çš„ä»å¥åªèƒ½æ˜¯ `statement`ã€‚`block` è¯­å¥å†…éƒ¨å¯ä»¥æ˜¯ `declaration`ã€‚

å¥½äº†ï¼Œææ¸…æ¥šè¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬å¯¹å¤„ç†è¯­å¥è¿›è¡Œæ”¯æŒäº†ã€‚å…ˆä»æœ€ç®€å•çš„è¯­å¥â€”â€”è¡¨è¾¾å¼è¯­å¥å¼€å§‹ã€‚

##### 2.2.5.1 è¡¨è¾¾å¼è¯­å¥

ç±»ä¼¼è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå®šä¹‰è¯­å¥çš„ç±»å‹ã€‚
```ts
type StmtType =
    | 'fun'
    | 'var'
    | 'if'
    | 'for'
    | 'block'
    | 'expression';

interface IStmt {
    type: StmtType;
    accept: <R>(visitor: IStmtVisitor<R>) => R;
}

interface IStmtVisitor<T> {
    visitFunStmt: (stmt: FunStmt) => T;
    visitVarStmt: (stmt: VarStmt) => T;
    visitIfStmt: (stmt: IfStmt) => T;
    visitForStmt: (stmt: ForStmt) => T;
    visitBlockStmt: (stmt: BlockStmt) => T;
    visitExprStmt: (stmt: ExprStmt) => T;
}
```
è¿™æ¬¡æˆ‘ä»¬è¦ä¸€å¹¶æŠŠæ‰§è¡Œé˜¶æ®µéœ€è¦çš„è®¿é—®è€…æ¨¡å¼çš„æ¥å£ç­‰éƒ½å‡†å¤‡å¥½ã€‚æ¥ç€æ˜¯å®šä¹‰ `ExprStmt`:
```ts
class ExprStmt implements IStmt {
    type: 'expression' = 'expression';
    expression: IExpr;

    constructor(expr: IExpr) {
        this.expression = expr;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitExprStmt(this);
    }
}
```

ç„¶åï¼Œæˆ‘ä»¬è¦ä¿®æ”¹ `parse` å‡½æ•°äº†ï¼š
```ts
class Parser {
    // ...

    parse(): IStmt[] {
        const stmts: IStmt[] = [];
        while (!this.isAtEnd()) {
            stmts.push(this.statement());
        }
        return stmts;
    }

    private statement(): IStmt {
        // TODO
    }

    // ...
}
```
`parse` å‡½æ•°çš„è¾“å‡ºä»è¡¨è¾¾å¼å˜æˆäº†è¯­å¥çš„æ•°ç»„ã€‚`statement` å‡½æ•°åœ¨ä¸€ä¸ªä¸€ä¸ªè§£æè¯­å¥ã€‚é‚£æˆ‘ä»¬åŠ å…¥è¡¨è¾¾å¼è¯­å¥ï¼š

```ts
class Parser {
    // ...

    private statement(): IStmt {
        return this.expressionStatement();
    }

    private expressionStatement() {
        const expr = this.expression();
        this.consume(';', 'Expect ";" after expression.');
        return new ExprStmt(expr);
    }

    private consume(tokenType: TokenType, message: string) {
        if (this.check(tokenType)) {
            this.advance();
            return;
        }
        throw new ParseError(message);
    }

    // ...
}
```
ğŸ˜„å¾ˆç®€å•å§ï¼

æˆ‘ä»¬å†æ¥çœ‹ type ç‰ˆã€‚å…ˆä»è¯­å¥å®šä¹‰å¼€å§‹ï¼Œ`StmtType` å®Œå…¨ä¸€è‡´ï¼Œå…¶ä»–çš„å¦‚ä¸‹ï¼š
```ts
interface Stmt {
    type: StmtType;
}

interface ExprStmt extends Stmt {
    type: 'expression';
    expression: Expr;
}

interface BuildExprStmt<E extends Expr> extends ExprStmt {
    expression: E;
}
```

åŒæ ·çš„è¦ä¿®æ”¹ `Parse` å‡½æ•°ï¼š
```ts
type Parse<Tokens extends Token[], Stmts extends Stmt[] = []> =
    Tokens extends [EOF]
        ? Stmts
        : ParseStmt<Tokens> extends infer Result
            ? Result extends ParseStmtSuccess<infer R, infer Rest>
                ? Parse<Rest, Push<Stmts, R>>
                : Result // error
            : NoWay<'Parse'>;

type ParseStmtError<M extends string> =
    ErrorResult<`[ParseStmtError]: ${M}`>;
type ParseStmtSuccess<R extends Stmt, T extends Token[]> =
    SuccessResult<{ stmt: R, rest: T }>;
```

`ParseStmt` å’Œ `ParseExprStmt` ä¹ŸåŒæ ·ç®€å•ï¼š
```ts
type ParseStmt<Tokens extends Token[]> = ParseExprStmt<Tokens>;

type ParseExprStmt<Tokens extends Token[], R = ParseExpr<Tokens>> =
    R extends ParseExprSuccess<infer Expr, infer Rest>
        ? Rest extends Match<TokenLike<';'>, infer Rest>
            ? ParseStmtSuccess<BuildExprStmt<Expr>, Rest>
            : ParseStmtError<'Expect ";" after expression.'>
        : R; // error
```
ä»¥ä¸Šæˆ‘ä»¬å®Œæˆäº†è¡¨è¾¾å¼è¯­å¥çš„è¯­æ³•åˆ†æéƒ¨åˆ†ï¼Œè¿™æ˜¯ä¸€ä¸ªç®€å•æ„‰å¿«çš„å¼€å§‹ã€‚æ¥ä¸‹æ¥è¦è®©å®ƒèƒ½æ‰§è¡Œèµ·æ¥ã€‚

è¯´èµ·æ‰§è¡Œï¼Œæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œè¯­å¥æ˜¯æ²¡æœ‰å€¼çš„ã€‚å¯¹äºè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬æ‰§è¡Œçš„ç»“æœæ˜¯ä¸€ä¸ªå€¼ã€‚å¯¹äºè¯­å¥å¾€å¾€æ˜¯å…¶ä»–å‰¯ä½œç”¨ï¼ˆæ¯”å¦‚ä¿®æ”¹å˜é‡ï¼Œæ“ä½œIOç­‰ï¼‰ï¼Œå¹¶ä¸ä¼šåƒè¡¨è¾¾å¼ä¸€æ ·å¾—åˆ°ä¸€ä¸ªå€¼ä½œä¸ºç»“æœã€‚å½“ç„¶è¿™åªæ˜¯é€šå¸¸æ„ä¹‰çš„è¯­å¥æ•ˆæœã€‚åœ¨æˆ‘ä»¬è¿™é‡Œï¼Œæƒ…å†µç‰¹æ®Šï¼Œæˆ‘ä»¬æƒ³è¦è¯­å¥åƒè¡¨è¾¾å¼ä¸€æ ·ï¼Œæœ€ç»ˆä¼šå¾—åˆ°ä¸€ä¸ªå€¼çš„ç»“æœã€‚ä¸ºä»€ä¹ˆè¦è¿™æ ·å‘¢ï¼Ÿä¸»è¦æ˜¯è€ƒè™‘åˆ° ts type ä¸­å¹¶æ²¡æœ‰ä»€ä¹ˆèƒ½æ“ä½œ IO è¿™æ ·èƒ½å¸¦æ¥å‰¯ä½œç”¨çš„èƒ½åŠ›ã€‚æˆ‘ä»¬æ— æ³•é€šè¿‡ç±»ä¼¼ `console.log` çš„æ–¹å¼â€œçœ‹â€åˆ°ç¨‹åºæ‰§è¡Œå¸¦æ¥çš„â€œå˜é‡â€ç­‰çš„å˜åŒ–ã€‚å¯ä»¥è§‚å¯Ÿç¨‹åºæ‰§è¡Œæ•ˆæœçš„å”¯ä¸€çš„æ–¹å¼æ˜¯è¿”å›å€¼ã€‚
* è¡¨è¾¾å¼è¯­å¥çš„è¿”å›å€¼æ˜¯è¡¨è¾¾å¼çš„å€¼ï¼›
* å¤šä¸ªè¯­å¥çš„å€¼æ˜¯æœ€åä¸€ä¸ªè¯­å¥çš„å€¼ï¼›
* var è¯­å¥çš„å€¼æ˜¯å˜é‡çš„å€¼ï¼›
* if è¯­å¥çš„å€¼æ˜¯å…¶ä¸ºçœŸå¯¹åº”è¯­å¥çš„å€¼ï¼Œæ²¡æœ‰å¯¹åº”è¯­å¥æˆ–è€…ç©ºè¯­å¥æ—¶å€¼ä¸º `null`;
* for è¯­å¥çš„å€¼æ˜¯å…¶å¾ªç¯å—å¯¹åº”è¯­å¥æœ€åä¸€æ¬¡æ‰§è¡Œçš„å€¼ï¼›
* å—è¯­å¥çš„å€¼æ˜¯å…¶å†…éƒ¨æœ€åä¸€ä¸ªè¯­å¥çš„å€¼ï¼Œç©ºå—çš„å€¼æ˜¯ `null`ï¼›
* ç©ºè¯­å¥çš„å€¼æ˜¯ `null`;
* å‡½æ•°å®šä¹‰è¯­å¥çš„å€¼æ˜¯å‡½æ•°ï¼›
* å‡½æ•°æ‰§è¡Œçš„è¿”å›å€¼æ˜¯æœ€åæ‰§è¡Œè¯­å¥çš„å€¼ï¼ˆæ˜¯çš„ï¼Œæ²¡æœ‰ `return` ä¹Ÿæœ‰è¿”å›å€¼ï¼‰ã€‚

ç°åœ¨æˆ‘ä»¬å¼€å§‹å®ç°æ‰§è¡Œã€‚é¦–å…ˆéœ€è¦è°ƒæ•´ `interpret` å‡½æ•°ï¼Œå®ƒçš„å…¥å‚ä»è¡¨è¾¾å¼å˜æˆäº†è¯­å¥æ•°ç»„ã€‚`Interpreter` ç±»è¿˜è¦å®ç° `IStmtVisitor<unknown>` æ¥å£ã€‚
```ts
class Interpreter implements IExprVisitor<unknown>,
                             IStmtVisitor<unknown> {
    // ...

    interpret(stmts: IStmt[]): ValueType {
        let lastResult: ValueType = null;
        for (const stmt of stmts) {
            lastResult = stmt.accept(this);
        }
        return lastResult;
    }

    // ...
}
```

å¯¹ `visitExprStmt` å‡½æ•°çš„å®ç°ï¼Œå¼‚å¸¸ç®€å•ğŸ˜„ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>,
                             IStmtVisitor<unknown> {
    // ...

    visitExprStmt(stmt: ExprStmt): ValueType {
        return stmt.expression.accept(this);
    }

    // ...
}
```
è¿™å°±æå®šäº†ï¼ŸğŸ˜„æ²¡é”™ï¼

é‚£ä¹ˆï¼Œtype ç‰ˆä¼šæœ‰è¿™ä¹ˆç®€å•å—ï¼Ÿæˆ‘ä»¬æ¥çœ‹çœ‹ï¼š
```ts
type Interpret<
    Stmts extends Stmt[],
    LastResult extends ValueType | null = null,
> = Stmts extends [infer S extends Stmt, ...infer Rest extends Stmt[]]
        ? InterpretStmt<S> extends infer R
            ? R extends InterpretStmtSuccess<infer Result>
                ? Interpret<Rest, Result>
                : R // error
            : NoWay<'Interpret'>
        : LastResult;

type InterpretStmtError<M extends string> =
    ErrorResult<`[InterpretStmtError]: ${M}`>;
type InterpretStmtSuccess<Value extends ValueType> =
    SuccessResult<{ value: Value }>;
```
è¿™å¥—è·¯å’Œ `Parse` ä¸€æ ·ã€‚`InterpretStmt` å’Œ `InterpretExprStmt` ä¹Ÿæ˜¯ä¸€æ ·çš„ç®€å•ï¼š

```ts
type InterpretStmt<S extends Stmt> =
    S extends ExprStmt
        ? InterpretExprStmt<S>
        : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;

type InterpretExprStmt<
    S extends ExprStmt,
    R = InterpretExpr<S['expression']>
> =
    R extends InterpretExprSuccess<infer V>
        ? InterpretStmtSuccess<V>
        : R; // error
```
ğŸ˜„å¤§åŠŸå‘Šæˆï¼


##### 2.2.5.2 var è¯­å¥

ç°åœ¨æˆ‘ä»¬æ¥æ”¯æŒå¾ˆå…³é”®çš„ç‰¹æ€§â€”â€”å˜é‡ã€‚é¦–å…ˆæ˜¯å£°æ˜å˜é‡çš„è¯­å¥ã€‚å…ˆçœ‹è¯­å¥ç±»å‹å®šä¹‰ï¼š
```ts
class VarStmt implements IStmt {
    type: 'var' = 'var';
    name: Token;
    initializer: IExpr | null;

    constructor(token: Token, initializer: IExpr | null) {
        this.name = token;
        this.initializer = initializer;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitVarStmt(this);
    }
}
```
`var` å±äº `declaration`ï¼Œæ‰€ä»¥åˆè¦ä¿®æ”¹ `parse` äº†ã€‚å¦å¤–è¯­æ³•åˆ†ææ—¶ï¼Œå’Œè¡¨è¾¾å¼é‚£è¾¹æœ‰ä¼˜å…ˆçº§ä¸åŒã€‚è¿™é‡Œè¦è¿›å…¥å˜é‡è¡¨è¾¾å¼çš„è§£æå‡½æ•°ï¼Œéœ€è¦å‰çœ‹æ˜¯å¦æ˜¯ `var` å…³é”®å­—ï¼Œå¦‚æœæ˜¯çš„è¯å¿…ç„¶æ˜¯å˜é‡å£°æ˜ã€‚
```ts
class Parser {
    // ...

    parse(): IStmt[] {
        const stmts: IStmt[] = [];
        while (!this.isAtEnd()) {
            stmts.push(this.declaration()); // <-- å˜åŠ¨
        }
        return stmts;
    }

    private declaration() {
        if (this.match('var')) {
            return this.varDeclaration();
        }

        return this.statement();
    }

    private varDeclaration() {
        // TODO
    }

    // ...
}
```

å†çœ‹ `varDeclaration`çš„å…·ä½“å®ç°ã€‚å£°æ˜å˜é‡æ—¶ï¼Œåˆå§‹åŒ–æ˜¯å¯é€‰çš„ã€‚åªæœ‰â€œçœ‹â€åˆ° `=` åï¼Œæ‰ä¼šè§£æåˆå§‹åŒ–è¡¨è¾¾å¼ï¼š
```ts
class Parser {
    // ...

    private varDeclaration() {
        this.consume('identifier', `Expect var name.`);
        const name = this.previous();
        let initializer = null;
        if (this.match('=')) {
            initializer = this.expression();
        }
        this.consume(';', `Expect ';' after var declaration.`);
        return new VarStmt(name, initializer);
    }

    // ...
}
```

æœ‰äº†è¡¨è¾¾å¼çš„å†ç»ƒï¼Œç°åœ¨è¿™äº›çœ‹èµ·æ¥éƒ½å¾ˆç®€å•ï¼Œå¯¹å§ğŸ˜‚ã€‚

å†æ¥çœ‹ type ç‰ˆçš„è¯­æ³•åˆ†æ, è¿˜æ˜¯å…ˆå®šä¹‰è¯­å¥ç±»å‹ï¼š
```ts
interface VarStmt extends Stmt {
    type: 'var';
    name: Identifier;
    initializer: Expr | null;
}

interface BuildVarStmt<N extends Identifier, E extends Expr | null> extends VarStmt {
    name: N;
    initializer: E;
}
```
æ¥ä¸‹æ¥æ˜¯ `ParseStmt` å’Œ `ParseVarStmt` å‡½æ•°ï¼š
```ts
type Parse<Tokens extends Token[], Stmts extends Stmt[] = []> =
    Tokens extends [EOF]
        ? Stmts
        : ParseDecl<Tokens> extends infer Result // <-- å˜åŠ¨
            ? Result extends ParseStmtSuccess<infer R, infer Rest>
                ? Parse<Rest, Push<Stmts, R>>
                : Result // error
            : NoWay<'Parse'>;

type ParseDecl<Tokens extends Token[]> =
    Tokens extends Match<TokenLike<'var'>, infer Rest>
        ? ParseVarStmt<Rest>
        : ParseStmt<Tokens>;

type ParseVarStmt<Tokens extends Token[]> =
    Tokens extends Match<infer VarName extends Identifier, infer Rest>
        ? Rest extends Match<TokenLike<';'>, infer Rest>
            ? ParseStmtSuccess<BuildVarStmt<VarName, null>, Rest>
            : Rest extends Match<TokenLike<'='>, infer Rest>
                ? ParseExpr<Rest> extends ParseExprSuccess<infer Exp, infer Rest>
                    ? Rest extends Match<TokenLike<';'>, infer Rest>
                        ? ParseStmtSuccess<BuildVarStmt<VarName, Exp>, Rest>
                        : ParseStmtError<'Expect ";" after var initializer expression.'>
                    : ParseStmtError<'Parse var initializer expression failed.'>
                : ParseStmtError<'Expect ";" or "=" after var name.'>
        : ParseStmtError<'Expect var name.'>;
```
`ParseVarStmt` çœ‹èµ·æ¥å¾ˆéº»çƒ¦ï¼Œä½†æ˜¯å®ƒæ˜¯æŒ‰ç…§ ts ç‰ˆç¿»è¯‘è¿‡æ¥çš„ã€‚ç”±äº type ç³»ç»Ÿçš„è¯­æ³•ç³–å°‘ï¼Œå†™èµ·æ¥æœ‰äº›å•°å—¦ã€‚ä¸è¿‡ï¼Œè¿˜æ˜¯èƒ½å®Œæˆä»»åŠ¡çš„ã€‚

æˆ‘ä»¬å®Œæˆäº†è¯­æ³•åˆ†æã€‚è¯¥å®ç°æ‰§è¡Œäº†ã€‚è¯•æƒ³ä¸€ä¸‹ `var a = 1; a + 2;`, è¿™ä¸ªç»“æœæˆ‘ä»¬éƒ½çŸ¥é“æ˜¯ 3ï¼Œå› ä¸º a ä»£è¡¨çš„å€¼æ˜¯ 1ã€‚ä½†è¡¨è¾¾å¼åœ¨æ‰§è¡Œæ—¶ï¼Œæ˜¯å¦‚ä½•çŸ¥é“ a ä»£è¡¨çš„å€¼æ˜¯ 1 å‘¢ï¼Ÿè¿™å°±éœ€è¦ä¿å­˜è¿™ä¸ªæ˜ å°„å…³ç³»ï¼Œç„¶åè¡¨è¾¾å¼æ‰§è¡Œçš„æ—¶å€™ï¼Œå°±èƒ½æŸ¥åˆ°äº†ã€‚é‚£ä¹ˆä¿å­˜è¿™ä¸ªæ˜ å°„å…³ç³»çš„å°±æ˜¯ç¯å¢ƒã€‚

##### 2.2.5.3 ç¯å¢ƒ

ç¯å¢ƒå¯ä»¥å­˜å‚¨å½“å‰å˜é‡å¯¹åº”çš„å€¼ã€‚å¦å¤–ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œæˆ‘ä»¬å»ºä¸€ä¸ªæ–°ç±» `Environment`ï¼Œå¹¶æä¾›æ–¹ä¾¿å˜é‡å®šä¹‰ï¼ŒæŸ¥è¯¢ä»¥åŠèµ‹å€¼çš„æ¥å£ã€‚å†…éƒ¨ç”¨ `Map` æ¥åšå­˜å‚¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®šä¹‰å˜é‡æ—¶ï¼Œå¦‚æœå·²ç»å­˜åœ¨å°±è¦æç¤ºå·²ç»å®šä¹‰çš„é”™è¯¯ï¼›æŸ¥è¯¢æ—¶ï¼Œæ²¡æ‰¾åˆ°å˜é‡ï¼Œè¦æç¤ºæœªå®šä¹‰çš„é”™è¯¯ï¼›èµ‹å€¼ä¹Ÿæ˜¯è€ƒè™‘æœªå®šä¹‰é”™è¯¯ã€‚
```ts
class Environment {
    private store: Map<string, ValueType>;

    constructor() {
        this.store = new Map<string, ValueType>();
    }

    define(name: Token, value: ValueType) {
        if (this.store.has(name.lexeme)) {
            throw new RuntimeError(`Variable '${name.lexeme}' is already defined.`);
        }

        this.store.set(name.lexeme, value);
    }

    get(name: Token): ValueType {
        let v = this.store.get(name.lexeme);

        if (v === undefined) {
            throw new RuntimeError(`Undefined variable '${name.lexeme}'.`);
        }

        return v;
    }

    assign(name: Token, value: ValueType) {
        if (this.store.has(name.lexeme)) {
            this.store.set(name.lexeme, value);
            return;
        }

        throw new RuntimeError(`Undefined variable '${name.lexeme}'.`);
    }
}
```

å“ˆå“ˆï¼Œts ç‰ˆæœ¬çš„ `Environment` å¾ˆå®¹æ˜“å®ç°ã€‚type ç‰ˆæœ¬å‘¢ï¼Ÿ

é¦–å…ˆï¼Œæ²¡æœ‰å˜é‡ï¼Œæ„å‘³ç€æ²¡æ³•ä¿®æ”¹ã€‚è¿™æ ·æˆ‘ä»¬åªèƒ½è¿”å›ä¸€ä¸ªæ–°çš„ `Environment`ã€‚å­˜å‚¨æˆ‘ä»¬ç”¨å¯¹è±¡, `set` æ—¶å°±æ˜¯æ›¿æ¢å¯¹è±¡å±æ€§ï¼Œå¹¶è¿”å›æ–°å¯¹è±¡ã€‚æ›¿æ¢å¯¹è±¡å±æ€§çš„ä»£ç å¦‚ä¸‹ï¼š
```ts
type ReplaceObjProp<O extends {}, K extends string, V extends unknown> = Omit<O, K> & { [Key in K]: V };
```
æŒæ¡è¿™ä¸ªæ–¹æ³•åï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å®ç°ä¸€ä¸ª `Map` ä¾› type ç‰ˆçš„ `Environment`ä½¿ç”¨ï¼š
```ts
// ä¸ºäº†é¿å…å’Œ js åŸç”Ÿçš„ Map é‡åï¼Œå–åä¸º TocMap
type TocMap = { [key: string]: ValueType };

type MapSet<
    M extends TocMap,
    K extends string,
    V extends ValueType,
> = Omit<M, K> & { [Key in K]: V };

type MapGet<
    M extends TocMap,
    K extends string,
> = M[K];

type MapHas<
    M extends TocMap,
    K extends string,
> = K extends keyof M ? true : false;
```
æ¥ä¸‹æ¥ï¼Œå®ç° `Environment` å°±å®¹æ˜“äº†ï¼š
```ts
interface Environment {
    store: TocMap;
}

interface BuildEnv<
    Initializer extends TocMap = {},
> extends Environment {
    store: Initializer;
}

type EnvDefine<
    Env extends Environment,
    Key extends string,
    Value extends ValueType,
    Store extends TocMap = Env['store']
> = MapHas<Store, Key> extends true
    ? RuntimeError<`Variable '${Key}' already defined.`>
    : BuildEnv<MapSet<Store, Key, Value>>;

type EnvGet<
    Env extends Environment,
    Key extends string,
    Store extends TocMap = Env['store'],
> = MapHas<Store, Key> extends true
    ? MapGet<Store, Key>
    : RuntimeError<`Undefined variable '${Key}'.`>;

type EnvAssign<
    Env extends Environment,
    Key extends string,
    Value extends ValueType,
    Store extends TocMap = Env['store'],
> = MapHas<Store, Key> extends true
    ? BuildEnv<MapSet<Store, Key, Value>>
    : RuntimeError<`Undefined variable '${Key}'.`>;
```

type ç‰ˆçš„ `Environment` ä¹Ÿå‡†å¤‡å¥½äº†ã€‚æˆ‘ä»¬ç°åœ¨å›å¤´æ¥å®ç° `var` è¯­å¥çš„æ‰§è¡Œéƒ¨åˆ†ï¼Œå…ˆæ˜¯ ts ç‰ˆã€‚

è§£é‡Šå™¨åˆå§‹åŒ–æ—¶ï¼Œå°±é»˜è®¤äº§ç”Ÿäº†ä¸€ä¸ªç¯å¢ƒã€‚æ‰€ä»¥å¯¹ `Interpreter` ç±»åšä¸€ç‚¹è°ƒæ•´ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    private environment: Environment;

    constructor() {
        this.environment = new Environment();
    }
    // ...
}
```

æ¥ä¸‹æ¥å°±æ˜¯å®ç° `visitVarStmt` äº†ï¼Œè¦æ³¨æ„çš„æ˜¯ï¼Œ`Toc` å¯¹æ²¡æœ‰åˆå§‹åŒ–çš„å˜é‡ä¸€å¾‹ç»™ `null` ä½œä¸ºé»˜è®¤åˆå§‹å€¼ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitVarStmt(stmt: VarStmt): ValueType {
        let initializer = null;
        if (stmt.initializer) {
            initializer = stmt.initializer.accept(this);
        }
        this.environment.define(stmt.name, initializer);
        return initializer;
    }

    // ...
}
```
ğŸ˜„å¾ˆé¡ºåˆ©ï¼

å†æ¥å®ç° type ç‰ˆã€‚åŒæ ·åˆå§‹è¦æœ‰ä¸€ä¸ªç¯å¢ƒï¼š
```ts
type Interpret<
    Stmts extends Stmt[],
    Env extends Environment = BuildEnv<{}>, // æ·»åŠ  Env å…¥å‚
    LastResult extends ValueType | null = null,
> = Stmts extends [infer S extends Stmt, ...infer Rest extends Stmt[]]
        ? InterpretStmt<S, Env> extends infer R // InterpretStmt ä¹Ÿè¦æºå¸¦å‚æ•° Env ğŸ˜‚
            ? R extends InterpretStmtSuccess<infer Result, infer Env> // è¿˜è¦ä»ç»“æœä¸­æŠŠ Env å–å‡ºæ¥ ğŸ¤¦â€
                ? Interpret<Rest, Env, Result> // æºå¸¦å‚æ•° Env
                : R // error
            : NoWay<'Interpret'>
        : LastResult;
```
ç›¸ä¿¡ä½ æ„Ÿå—åˆ°äº†ï¼ŒåŠ  Env ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“çš„ã€‚æˆ‘ä»¬è¦ä¿®æ”¹å¾ˆå¤šåœ°æ–¹ ğŸ˜‚ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºæ²¡æœ‰å˜é‡ï¼æˆ‘ä»¬æ— æ³•ä¿®æ”¹å…¨å±€ï¼Œæˆ–è€…èƒ½è®¿é—®çš„æŸä¸ªå±€éƒ¨å˜é‡ã€‚æ‰€ä»¥ä¸€æ—¦æœ‰ä¿®æ”¹ Env çš„æƒ…å†µæ—¶ï¼Œå¿…é¡»è¿”å›ä¸€ä¸ªæ–°çš„ Envã€‚è¿™æ ·çš„è¯ï¼ŒæŸä¸ªå‡½æ•°æ€ä¹ˆçŸ¥é“ï¼Œå®ƒæ‹¿åˆ°çš„æ˜¯æœ€æ–°çš„ Env å‘¢ï¼ŸğŸ¤· åªèƒ½åœ¨æ¯ä¸ªéœ€è¦çš„å‡½æ•°ä¸ŠåŠ ä¸€ä¸ªå…¥å‚ Env, åœ¨è°ƒç”¨å®ƒæ—¶ä¼ ç»™å®ƒæœ€æ–°çš„ Envã€‚ğŸ˜‚åœ¨è¿™é‡Œï¼Œæˆ‘çœŸçš„å¾ˆæƒ³å¿µå˜é‡å•Šï¼æ²¡åŠæ³•ï¼Œæˆ‘ä»¬è¿˜è¦ç»§ç»­å‰è¡Œã€‚æˆ‘ä»¬åªèƒ½ç»•ã€‚ç°åœ¨æ¥æ€»ç»“ä¸€ä¸‹ï¼Œè¦åŠ  Env, è¦åšå“ªäº›äº‹æƒ…å‘¢ï¼Ÿç®€å•æ¥è¯´å°±æ˜¯ï¼š

**éœ€è¦ Env çš„å‡½æ•°ï¼Œå¿…é¡»æœ‰ Env çš„å…¥å‚ï¼Œè¿”å›å€¼ä¹Ÿå¿…é¡»åŒ…å« Envã€‚**

åˆ°åº•æˆ‘ä»¬éœ€è¦ä¿®æ”¹å¤šå°‘å‡½æ•°å‘¢ï¼Ÿâ€”â€” å¯ä»¥è¯´æ˜¯ `Interpret` ç›¸å…³çš„å‡ ä¹æ‰€æœ‰å‡½æ•°ğŸ˜‚ã€‚è¿™é‡Œæˆ‘ä»¬å…ˆè´´ä¸€ä¸‹å…³äº `Result` çš„å·¥å…·å‡½æ•°ï¼š
```ts
type InterpretStmtSuccess<Value extends ValueType, Env extends Environment> = SuccessResult<{ value: Value, env: Env }>;
type InterpretExprSuccess<Value extends ValueType, Env extends Environment> = SuccessResult<{ value: Value, env: Env }>;
```

ç„¶åæ˜¯ `InterpretStmt` å’Œ `InterpretExpr`:
```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends ExprStmt
        ? InterpretExprStmt<S, Env>
        : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;

type InterpretExpr<E extends Expr, Env extends Environment> =
    E extends LiteralExpr
        ? InterpretExprSuccess<E['value'], Env>
        : E extends GroupExpr
            ? InterpretExpr<E['expression'], Env>
            : E extends UnaryExpr
                ? EvalUnaryExpr<E, Env>
                : E extends BinaryExpr
                    ? EvalBinaryExpr<E, Env>
                    : RuntimeError<`Unknown expression type: ${E['type']}`>;
```

`InterpretExprStmt`:
```ts
type InterpretExprStmt<
    S extends ExprStmt,
    Env extends Environment,
    R = InterpretExpr<S['expression'], Env>
> =
    R extends InterpretExprSuccess<infer V, infer Env>
        ? InterpretStmtSuccess<V, Env>
        : R; // error
```

å‚è€ƒä»¥ä¸Šï¼Œå…¶ä»–å‡½æ•°çš„ä¿®æ”¹ä½ åº”è¯¥ä¸ä¼šæœ‰é—®é¢˜äº†ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬å°±æ¥å®Œæˆ type ç‰ˆçš„ `VarStmt` æ‰§è¡Œå‡½æ•°ï¼š
```ts
type InterpretVarStmt<
    S extends VarStmt,
    Env extends Environment,
    Initializer = S['initializer']
> = Initializer extends Expr
    ? InterpretExpr<Initializer, Env> extends infer EV
        ? EV extends InterpretExprSuccess<infer V, infer Env>
            ? WrapVarStmtResult<V, EnvDefine<Env, S['name']['lexeme'], V>>
            : EV // error
        : NoWay<'InterpretVarStmt'>
    : WrapVarStmtResult<null, EnvDefine<Env, S['name']['lexeme'], null>>;

type WrapVarStmtResult<V extends ValueType, Env> = Env extends Environment
    ? InterpretStmtSuccess<V, Env>
    : Env; // error
```

å½“ç„¶åˆ«å¿˜è®°äº†ï¼Œ`InterpretStmt` è¦ä¿®æ”¹ä¸€ä¸‹ï¼Œè°ƒç”¨ `InterpretVarStmt`:
```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends VarStmt
        ? InterpretVarStmt<S, Env>
        : S extends ExprStmt
            ? InterpretExprStmt<S, Env>
            : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;
```
ç»ˆäºå®Œæˆäº†å£°æ˜å˜é‡çš„æ‰§è¡Œä»£ç äº†ğŸ˜€ã€‚å¯æ˜¯ç°åœ¨æˆ‘ä»¬è¿˜ä¸èƒ½è·‘èµ·æ¥è€è€ï¼Œå› ä¸ºæ²¡æœ‰ä½¿ç”¨å˜é‡çš„åœ°æ–¹ï¼Œæˆ‘ä»¬çœ‹ä¸åˆ°æ•ˆæœï¼Œé™¤é debugã€‚å¯¹äº ts ç‰ˆè¿˜å¥½è¯´ï¼Œtype ç‰ˆæ˜¯æ²¡æ³• debug çš„ã€‚æ‰€ä»¥æ¥ä¸‹æ¥æˆ‘ä»¬å°±æ¥å®Œæˆå¯¹å˜é‡èµ‹å€¼ä»¥åŠè¡¨è¾¾å¼ä¸­å¼•ç”¨å˜é‡çš„æ”¯æŒã€‚


##### 2.2.5.4 å˜é‡è¡¨è¾¾å¼å’Œèµ‹å€¼è¡¨è¾¾å¼

å‰é¢æˆ‘ä»¬åšè¡¨è¾¾å¼çš„è¯­æ³•åˆ†ææ—¶ï¼Œæœ‰ä¸€ä¸ªä¼˜å…ˆçº§åˆ—è¡¨ã€‚ç°åœ¨æˆ‘ä»¬åŠ å…¥è¿™ä¸¤ç§æ–°çš„è¡¨è¾¾å¼ï¼š
```ts
// è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ç”±ä½åˆ°é«˜ï¼š
// assign:      =                   å³ç»“åˆ            <-- æ–°å¢
// logic or:    ||                  å·¦ç»“åˆ
// logic and:   &&                  å·¦ç»“åˆ
// equality:    == !=               å·¦ç»“åˆ
// relation:    < > <= >=           å·¦ç»“åˆ
// additive:    + -                 å·¦ç»“åˆ
// factor:      * / %               å·¦ç»“åˆ
// unary:       !                   å³ç»“åˆ
// primary:     literal group identifier             <-- æ–°å¢ identifier
```

æœ‰äº†å®ƒæˆ‘ä»¬ç›´æ¥æŒ‰ç…§ä¹‹å‰å¥—è·¯æ¥å°±å¯ä»¥äº†ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹å˜é‡è¡¨è¾¾å¼ã€‚å“ˆï¼Œå˜é‡è¡¨è¾¾å¼å°±æ˜¯è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå˜é‡ã€‚ä¸¾ä¾‹ `var a = 2; a;`, è¿™é‡Œç¬¬äºŒä¸ªè¯­å¥çš„è¡¨è¾¾å¼å°±æ˜¯ä¸€ä¸ªå˜é‡è¡¨è¾¾å¼ã€‚

å…ˆå®šä¹‰ç±»å‹ï¼š
```ts
type ExprType =
    | 'group'
    | 'binary'
    | 'unary'
    | 'literal'
    | 'assign' // <-- æ–°å¢
    | 'variable'; // <-- æ–°å¢

interface IExprVisitor<T> {
    // ...
    visitAssignExpr: (expr: AssignExpr) => T; // <-- æ–°å¢
    visitVariableExpr: (expr: VariableExpr) => T; // <-- æ–°å¢
}

class VariableExpr implements IExpr {
    type: ExprType = 'variable';
    name: Token;

    constructor(name: Token) {
        this.name = name;
    }

    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitVariableExpr(this);
    }
}
```

åŒæ­¥å®šä¹‰ type ç‰ˆï¼š
```ts
// ExprType å’Œ ts ç‰ˆä¸€æ ·

interface VariableExpr extends Expr {
    type: 'variable';
    name: Identifier;
}

interface BuildVariableExpr<T extends Identifier> extends VariableExpr {
    name: T;
}
```

æ¥ä¸‹æ¥æ˜¯è¯­æ³•åˆ†æï¼Œå…ˆ ts ç‰ˆï¼š
```ts
class Parser {
    // ...

    private primary(): LiteralExpr() {
        if (this.match('number')) {
            return new LiteralExpr(this.previous().literal as number);
        } else if (this.match('true', 'false', 'null')) {
            const type = this.previous().type;
            if (type === 'null') {
                return new LiteralExpr(null);
            }
            return new LiteralExpr(type === 'true');
        } else if (this.match('string')) {
            return new LiteralExpr(this.previous().lexeme);
        // æ–°å¢å¼€å§‹
        } else if (this.match('identifier')) {
            return new VariableExpr(this.previous());
        // æ–°å¢ç»“æŸ
        } else if (this.match('(')) {
            const expr = this.expression(); // æ³¨æ„è¿™é‡Œé€’å½’è°ƒç”¨äº† expression()
            this.consume(')', 'Expect ")" after expression.');
            return new GroupExpr(expr);
        }

        throw new ParseError(`Expect expression, but got token: ${this.current().lexeme}.`);
    }

    // ...
}
```

type ç‰ˆï¼š
```ts
type ParsePrimary<Tokens extends Token[]> =
    Tokens extends Match<infer E extends Token, infer R>
        ? E extends { type: 'number', value: infer V extends number }
            ? ParseExprSuccess<BuildLiteralExpr<V>, R>
            : E extends { type: 'string', lexeme: infer V extends string }
                ? ParseExprSuccess<BuildLiteralExpr<V>, R>
                : E extends { type: infer B extends keyof Keywords }
                    ? ParseExprSuccess<BuildLiteralExpr<ToValue<B>>, R>
                    // æ–°å¢å¼€å§‹
                    : E extends Identifier
                        ? ParseExprSuccess<BuildVariableExpr<E>, R>
                    // æ–°å¢ç»“æŸ
                        : E extends TokenLike<'('>
                            ? ParseExpr<R> extends ParseExprSuccess<infer G, infer RG>
                                ? RG extends Match<TokenLike<')'>, infer Rest>
                                    ? ParseExprSuccess<BuildGroupExpr<G>, Rest>
                                    : ParseExprError<`Group not match ')'.`>
                                : ParseExprError<`Parse Group expression fail.`>
                            : ParseExprError<`Unknown token type: ${E['type']}, lexeme: ${E['lexeme']}`>
        : ParseExprError<`ParsePrimary fail`>;
```

å¥½äº†ï¼Œç°åœ¨æ¥æ”¯æŒèµ‹å€¼è¡¨è¾¾å¼ã€‚å…ˆå®šä¹‰ç±»å‹ï¼Œ
ts ç‰ˆæœ¬ï¼š
```ts
class AssignExpr implements IExpr {
    type: ExprType = 'assign';
    varName: Token;
    right: IExpr;

    constructor(varName: Token, right: IExpr) {
        this.varName = varName;
        this.right = right;
    }

    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitAssignExpr(this);
    }
}
```
type ç‰ˆæœ¬ï¼š
```ts
interface AssignExpr extends Expr {
    type: 'assign';
    varName: Token;
    right: Expr;
}

interface BuildAssignExpr<N extends Identifier, E extends Expr> extends AssignExpr {
    varName: N;
    right: E;
}
```

ä¸‹é¢è¿›è¡Œè¯­æ³•åˆ†æã€‚å®ƒçš„ä¼˜å…ˆçº§æœ€ä½ï¼Œæ‰€ä»¥è¡¨è¾¾å¼èµ·å§‹å°±è°ƒç”¨å®ƒï¼Œå®ƒå†è°ƒç”¨é€»è¾‘æˆ–å‡½æ•°ã€‚å®ƒçš„ç»“åˆæ€§æ˜¯å³ç»“åˆï¼Œå’Œé€»è¾‘å `!` ä¸€æ ·ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥æŠ„ä»£ç ğŸ˜€ï¼š
```ts
class Parser {
    // ...

    private expression(): IExpr {
        return this.assign();
    }

    private assign(): IExpr {
        const left = this.logicOr();
        if (this.match('=')) {
            const right = this.assign();

            if (left instanceof VariableExpr) {
                return new AssignExpr(left.name, right);
            }

            throw new ParseError('Invalid assignment target.');
        }
        return left;
    }

    // ...
}
```

åŒç†ï¼Œtype ç‰ˆçš„ä»£ç ï¼š
```ts
type ParseExpr<Tokens extends Token[]> = ParseAssign<Tokens>;

type ParseAssign<Tokens extends Token[], R = ParseLogicOr<Tokens>> =
    R extends ParseExprSuccess<infer Left, infer Rest>
        ? ParseAssignBody<Left, Rest>
        : R; // error

type ParseAssignBody<Left extends Expr, Tokens extends Token[]> =
Tokens extends Match<TokenLike<'='>, infer Rest>
    ? ParseAssign<Rest> extends ParseExprSuccess<infer Right, infer Rest>
        ? Left extends VariableExpr
            ? ParseExprSuccess<BuildAssignExpr<Left['name'], Right>, Rest>
            : ParseExprError<`Invalid assignment target: ${Left['type']}}`>
        : ParseExprError<`Parse right of assign variable fail: ${Rest[0]['lexeme']}`>
    : ParseExprSuccess<Left, Tokens>;
```

å“ˆï¼ç°åœ¨å¯ä»¥å¼€å§‹"è€"(ç©)å˜é‡äº†ğŸ˜€ã€‚


##### 2.2.5.5 ä½œç”¨åŸŸ

æˆ‘ä»¬ä¸‹ä¸€ä¸ªè¦å®ç°çš„æ˜¯å—è¯­å¥ã€‚å®ƒæœ‰ä¸€ä¸ªé‡è¦çš„ç‰¹ç‚¹å°±æ˜¯å˜é‡è¦†ç›–ã€‚ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿè¯·çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š
```ts
var a = 1;
{
    var a = "abc";
    a; // "abc"

    {
        var a = false;
        a; // false

        a = 6;
        a; // 6
    }

    a; // "abc"
}
a; // 1
```
ä¸Šé¢çš„ä»£ç å¤§å®¶å·²ç»å¸ç©ºè§æƒ¯äº†ã€‚å˜é‡è¦†ç›–å°±æ˜¯å­ä½œç”¨åŸŸçš„å˜é‡å±è”½äº†çˆ¶ä½œç”¨åŸŸçš„åŒåå˜é‡ã€‚é‚£æ€ä¹ˆå®ç°è¿™ä¸ªæ•ˆæœå‘¢ï¼Ÿæ¯ä¸ªè¯­å¥å—éƒ½æ˜¯ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œä½œç”¨åŸŸçš„å®ç°å…¶å®å°±æ˜¯ç¯å¢ƒã€‚

åªä¸è¿‡å½“å‰ï¼Œæˆ‘ä»¬çš„ `Environment` æ²¡æœ‰çˆ¶å­åµŒå¥—çš„æƒ…å†µã€‚ç°åœ¨æˆ‘ä»¬å°±æ¥æ”¯æŒå®ƒï¼Œåªéœ€è¦æ·»åŠ ä¸€ä¸ªæŒ‡å‘çˆ¶ç¯å¢ƒçš„å˜é‡å³å¯ã€‚æœ€å¤–é¢çš„ç¯å¢ƒçš„çˆ¶ç¯å¢ƒä¸º `null`, è¿™é‡Œæˆ‘æŠŠæŒ‡å‘çˆ¶ç¯å¢ƒçš„å˜é‡å‘½åä¸º `outer`ï¼ˆæˆ‘æŠŠçˆ¶ç¯å¢ƒç§°ä¸ºå¤–éƒ¨ç¯å¢ƒè€Œå·²ğŸ˜€ï¼‰:
```ts
class Environment {
    private store: Map<string, ValueType>;
    private outer: Environment | null;

    constructor(env: Environment | null) {
        this.store = new Map<string, ValueType>();
        this.outer = env;
    }

    // ...
}
```

åŒæ—¶ï¼Œå¯¹å¤–æä¾›çš„ api éƒ½è¦åšä¸€äº›è°ƒæ•´ã€‚ä½† `define` ä¸ç”¨ï¼Œå› ä¸ºå®šä¹‰åªç”¨å…³æ³¨å½“å‰ä½œç”¨åŸŸã€‚`get` åœ¨å½“å‰ä½œç”¨åŸŸæ‰¾ä¸åˆ°ï¼Œå°±å‘å¤–ç¯å¢ƒæ‰¾ã€‚`assign` ä¹Ÿæ˜¯ä¸€æ ·ï¼š
```ts
class Environment {
    // ...

    get(name: Token): ValueType {
        let v = this.store.get(name.lexeme);
        // æ–°å¢å¼€å§‹
        if (v === undefined && this.outer) {
            v = this.outer.get(name);
        }
        // æ–°å¢ç»“æŸ

        if (v === undefined) {
            throw new RuntimeError(`Undefined variable '${name.lexeme}'.`);
        }

        return v;
    }

    assign(name: Token, value: ValueType) {
        if (this.store.has(name.lexeme)) {
            this.store.set(name.lexeme, value);
            return;
        }

        // æ–°å¢å¼€å§‹
        if (this.outer) {
            this.outer.assign(name, value);
            return;
        }
        // æ–°å¢ç»“æŸ

        throw new RuntimeError(`Undefined variable '${name.lexeme}'.`);
    }
}
```

type ç‰ˆï¼Œ ä¹Ÿæ˜¯ä¸€æ ·ã€‚å…ˆæ·»åŠ æŒ‡å‘å¤–å›´ç¯å¢ƒçš„å¸¸é‡ï¼š
```ts
interface Environment {
    store: TocMap;
    outer: Environment | null; // <-- æ–°å¢
}

interface BuildEnv<
    Initializer extends TocMap = {},
    Outer extends Environment | null = null, // <-- æ–°å¢
> extends Environment {
    store: Initializer;
    outer: Outer; // <-- æ–°å¢
}
```

å†ä¿®æ”¹ `EnvGet` å’Œ `EnvAssign` çš„å®ç°ï¼š
```ts
type EnvGet<
    Env extends Environment,
    Key extends string,
    Store extends TocMap = Env['store'],
    Outer = Env['outer'],
> = MapHas<Store, Key> extends true
    ? MapGet<Store, Key>
    // æ–°å¢å¼€å§‹
    : Outer extends Environment
        ? EnvGet<Outer, Key>
    // æ–°å¢ç»“æŸ
        : RuntimeError<`Undefined variable '${Key}'.`>;

type EnvAssign<
    Env extends Environment,
    Key extends string,
    Value extends ValueType,
    Store extends TocMap = Env['store'],
    Outer extends Environment | null = Env['outer'],
> = MapHas<Store, Key> extends true
    ? BuildEnv<MapSet<Store, Key, Value>, Outer>
    // æ–°å¢å¼€å§‹
    : Outer extends Environment
        ? EnvAssign<Outer, Key, Value> extends infer NewOuter
            ? NewOuter extends Environment
                ? BuildEnv<Store, NewOuter>
                : NewOuter // error
            : NoWay<'EnvAssign'>
    // æ–°å¢ç»“æŸ
        : RuntimeError<`Undefined variable '${Key}'.`>;
```

æœ€ååˆ«å¿˜äº†ï¼Œåˆ›å»ºä¿®æ”¹åˆå§‹ `Environment` æ—¶ï¼Œéœ€è¦ä¼ ä¸€ä¸ª `outer` å‚æ•°ï¼Œç”±äºæ˜¯æœ€å¤–å±‚ï¼Œæ‰€ä»¥ç›´æ¥ç»™ `null` å€¼ã€‚


##### 2.2.5.6 block è¯­å¥

ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹å®ç°å—è¯­å¥çš„è¯­æ³•åˆ†æäº†ã€‚é¦–å…ˆæ¥å®šä¹‰ç±»å‹, ts ç‰ˆï¼š
```ts
class BlockStmt implements IStmt {
    type: 'block' = 'block';
    stmts: IStmt[];

    constructor(stmts: IStmt[]) {
        this.stmts = stmts;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitBlockStmt(this);
    }
}
```

type ç‰ˆï¼š
```ts
interface BlockStmt extends Stmt {
    type: 'block';
    stmts: Stmt[];
}

interface BuildBlockStmt<Stmts extends Stmt[]> extends BlockStmt {
    stmts: Stmts;
}
```

ç°åœ¨æ¥çœ‹è¯­æ³•åˆ†æä»£ç ã€‚ts ç‰ˆï¼š
```ts
class Parser {
    // ...

    private statement(): IStmt {
        // æ–°å¢å¼€å§‹
        if (this.match('{')) {
            return this.blockStatement();
        }
        // æ–°å¢ç»“æŸ

        return this.expressionStatement();
    }

    private blockStatement(): BlockStmt {
        const stmts: IStmt[] = [];
        while(!this.isAtEnd() && !this.match('}')) {
            stmts.push(this.declaration());
        }

        if (this.previous().type !== '}') {
            throw new ParseError('Expect "}" end the block.');
        }

        return new BlockStmt(stmts);
    }

    // ...
}
```

type ç‰ˆï¼š
```ts
type ParseStmt<Tokens extends Token[]> =
    // æ–°å¢å¼€å§‹
    Tokens extends Match<TokenLike<'{'>, infer Rest>
        ? ParseBlockStmt<Rest>
        // æ–°å¢ç»“æŸ
        : ParseExprStmt<Tokens>;

type ParseBlockStmt<
    Tokens extends Token[],
    Stmts extends Stmt[] = [],
> = Tokens extends [EOF]
    ? ParseStmtError<'Expect "}" close block statement.'>
    : Tokens extends Match<TokenLike<'}'>, infer Rest>
        ? ParseStmtSuccess<BuildBlockStmt<Stmts>, Rest>
        : ParseBlockStmtBody<ParseDecl<Tokens>, Stmts>;

type ParseBlockStmtBody<SR, Stmts extends Stmt[]> =
    SR extends ParseStmtSuccess<infer S, infer R>
        ? ParseBlockStmt<R, Push<Stmts, S>>
        : SR; // error
```

è¯­æ³•åˆ†ææå®šã€‚å†æ¥å†™æ‰§è¡Œé˜¶æ®µã€‚å¯¹äº ts ç‰ˆï¼Œå°±æ˜¯å®ç° `visitBlockStmt`ã€‚åœ¨æ‰§è¡Œå—å†…è¯­å¥ä¹‹å‰ï¼Œè¦äº§ç”Ÿä¸€ä¸ªæ–°ç¯å¢ƒï¼Œæ‰§è¡Œå®Œä¹‹åï¼Œè¿˜è¦æ¢å¤åˆ°ä¹‹å‰çš„ç¯å¢ƒã€‚
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitBlockStmt(blockStmt: BlockStmt): ValueType {
        const previousEnv = this.environment;

        try {
            this.environment = new Environment(previousEnv);

            let lastResult: ValueType = null;
            for (const stmt of blockStmt.stmts) {
                lastResult = stmt.accept(this);
            }
            return lastResult;
        } finally {
            this.environment = previousEnv;
        }
    }

    // ...
}
```

ä¸‹é¢è¯¥ type ç‰ˆã€‚çœ‹è¿™é‡Œå¦‚ä½•ä¿è¯æ‰§è¡Œå—è¯­å¥ç”¨æ–°ç¯å¢ƒï¼Œæ‰§è¡Œå®Œåç”¨æ—§ç¯å¢ƒã€‚è¿™é‡Œåˆä¸ªé™·é˜±ã€‚ä½ ä¸èƒ½æŒ‰ç…§ ts ç‰ˆæœ¬çš„ä»£ç æ¥ç¿»è¯‘ã€‚äºŒè€…ä»è¯­è¨€å±‚é¢æœ‰é‡å¤§å·®å¼‚ï¼Œè¿™é‡Œæ²¡æœ‰å˜é‡ï¼Œæ— æ³•ä¿®æ”¹å·²æœ‰çš„ç¯å¢ƒã€‚ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨å—è¯­å¥ä¸­ä¿®æ”¹äº†å¤–éƒ¨ç¯å¢ƒçš„æŸä¸ªå˜é‡ï¼Œé‚£ä¹ˆå—è¯­å¥æ‰§è¡Œå®Œåï¼Œè™½ç„¶æ¢å¤åˆ°ä¹‹å‰çš„ç¯å¢ƒã€‚ä½†å¯¹äº ts ç‰ˆæœ¬æ¥è¯´ï¼Œæ¢å¤çš„ç¯å¢ƒå’ŒåŸæ¥è¿˜å®Œå…¨ä¸€æ ·å—ï¼Ÿå½“ç„¶ä¸ä¸€æ ·äº†ï¼Œé‡Œé¢çš„é‚£ä¸ªå˜é‡çš„å€¼å˜äº†ã€‚æ‰€ä»¥è¯´æ¢å¤ï¼Œä»…ä»…æ˜¯å¼•ç”¨æ¢å¤ã€‚é‚£ä¹ˆå¯¹äº type ç‰ˆï¼Œè¯¥æ€ä¹ˆå¤„ç†å‘¢ï¼ŸæŒ‰ç…§è¿™ä¸ªä¾‹å­ï¼Œä¿®æ”¹å¤–éƒ¨ç¯å¢ƒåï¼Œtype ç‰ˆä¸­çš„ `Env` è¦æ–°ç”Ÿæˆä¸€ä¸ªï¼Œ`outer` æŒ‡å‘çš„å¤–éƒ¨ç¯å¢ƒä¹Ÿæ˜¯æ–°ç”Ÿæˆçš„ï¼Œå®ƒåŒ…å«äº†å˜é‡çš„æ–°å€¼ã€‚æ‰€ä»¥åœ¨æ‰§è¡Œå®Œå—è¯­å¥åï¼Œè¦â€œæ¢å¤â€çš„å¤–éƒ¨ç¯å¢ƒå°±æ˜¯ `Env['outer']`ã€‚
```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends VarStmt
        ? InterpretVarStmt<S, Env>
        : S extends ExprStmt
            ? InterpretExprStmt<S, Env>
            : S extends BlockStmt
                ? InterpretBlockStmt<S['stmts'], BuildEnv<{}, Env>>
                : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;

type InterpretBlockStmt<
    Stmts extends Stmt[],
    NewEnv extends Environment,
    LastResult extends ValueType = null
> = Stmts extends [infer S extends Stmt, ...infer Rest extends Stmt[]]
    ? InterpretBlockStmtBody<InterpretStmt<S, NewEnv>, Rest>
    : InterpretStmtSuccess<LastResult, Safe<NewEnv['outer'], Environment>>;

type InterpretBlockStmtBody<
    RV,
    Rest extends Stmt[],
> =
    RV extends InterpretStmtSuccess<infer V, infer NewEnv>
        ? InterpretBlockStmt<Rest, NewEnv, V>
        : RV; // error
```

å•Šï¼æˆ‘ä»¬å®Œæˆå—è¯­å¥äº†ã€‚ç€å‰è¿›äº†ä¸€å¤§æ­¥ï¼Œåç»­çš„ `if` è¯­å¥ï¼Œ`for` è¯­å¥ï¼Œè¿˜æœ‰å‡½æ•°éƒ½éœ€è¦å®ƒã€‚

##### 2.2.5.7 if è¯­å¥

è¯´åˆ°å¯¹æ¡ä»¶æ§åˆ¶çš„æ”¯æŒï¼Œæˆ‘ä»¬ç›®å‰çš„ `Toc` å°±å·²ç»æœ‰äº†ã€‚æ²¡é”™ï¼Œå°±æ˜¯é€»è¾‘ä¸å’Œé€»è¾‘æˆ–ã€‚é€šè¿‡å®ƒä»¬çš„çŸ­è·¯èƒ½åŠ›ï¼Œä½ å·²ç»å¯ä»¥å®ç°ç±»ä¼¼ `if-else` è¯­å¥çš„èƒ½åŠ›äº†ã€‚ä½†æ˜¯æˆ‘æƒ³ä½ åœ¨å®ç° type ç‰ˆçš„ `Toc` æ—¶ï¼Œå·²ç»æ·±æ·±æ„Ÿè§‰åˆ°ï¼Œç¼ºâ€œç³–â€çš„è¯­æ³•å†™èµ·æ¥æœ‰å¤šä¹ˆå•°å—¦å’Œæ¯ç‡¥ã€‚æ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯è¦å®ç° `if` è¯­å¥ã€‚

è¿˜æ˜¯ä¸€æ ·ï¼Œå…ˆå®šä¹‰è¯­å¥çš„ç±»å‹ï¼š
```ts
class IfStmt implements IStmt {
    type: 'if' = 'if';
    condition: IExpr;
    ifClause: IStmt;
    elseClause: IStmt | null;

    constructor(
        cond: IExpr,
        ifClause: IStmt,
        elseClause: IStmt | null = null) {
        this.condition = cond;
        this.ifClause = ifClause;
        this.elseClause = elseClause;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitIfStmt(this);
    }
}
```

type ç‰ˆæœ¬ï¼š
```ts
interface IfStmt extends Stmt {
    type: 'if';
    condition: Expr;
    ifClause: Stmt;
    elseClause: Stmt | null;
}

interface BuildIfStmt<
    Condition extends Expr,
    IfClause extends Stmt,
    ElseClause extends Stmt | null = null
> extends IfStmt {
    condition: Condition;
    ifClause: IfClause;
    elseClause: ElseClause;
}
```

ç°åœ¨å¼€å§‹è¯­æ³•åˆ†æã€‚
```ts
class Parser {
    // ...

    private statement(): IStmt {
        if (this.match('{')) {
            return this.blockStatement();
        // æ–°å¢å¼€å§‹
        } else if (this.match('if')) {
            return this.ifStatement();
        // æ–°å¢ç»“æŸ
        }

        return this.expressionStatement();
    }

    private ifStatement(): IfStmt {
        this.consume('(', 'Expect "(" before if condition.');
        const condition = this.expression();
        this.consume(')', 'Expect ")" after if condition.');
        const ifClause = this.statement();
        let elseClause = null;
        if (this.match('else')) {
            elseClause = this.statement();
        }
        return new IfStmt(condition, ifClause, elseClause);
    }

    // ...
}
```
ä¸çŸ¥é“ä½ æœ‰æ²¡æœ‰æ„è¯†åˆ°ä¸€ä¸ªé—®é¢˜ã€‚å°±æ˜¯ `if-else` é…å¯¹é—®é¢˜ã€‚æ¯”å¦‚ä»£ç ï¼š
```ts
var a = 1;
if (a > 1) if (a == 1) a = 0; else a = 10;
a; // ?
```
ä½ è®¤ä¸º `a` å€¼å› è¯¥æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬åˆ—å‡ºä¸¤ç§ç»“æœå¯¹åº”çš„é…å¯¹ï¼š
```ts
// a = 1 å¯¹åº”å¦‚ä¸‹ï¼š
if (a > 1) {
    if (a == 1) {
        a = 0;
    } else {
        a = 10;
    }
}

// a = 10 å¯¹åº”å¦‚ä¸‹ï¼š
if (a > 1) {
    if (a == 1) {
        a = 0;
    }
} else {
    a = 10;
}
```
å“ªä¸ªæ˜¯å¯¹çš„å‘¢ï¼Ÿå“¦ï¼Œæˆ‘ä»¬æ˜¯è¯­è¨€è®¾è®¡è€…ï¼Œæˆ–è®¸åº”è¯¥è¯´ï¼Œæˆ‘ä»¬è¦å“ªä¸ªï¼Ÿæˆ‘çš„ç­”æ¡ˆæ˜¯å’Œå¸¸è§çš„è¯­è¨€ä¸€è‡´ã€‚ä¹Ÿå°±æ˜¯é‡‡å–ç¬¬ä¸€ç§ã€‚å¸¸è§çš„è¯­è¨€éƒ½æ˜¯é‡‡ç”¨ï¼Œå°† `else` ä¸æœ€æ¥è¿‘ `if` é…å¯¹ã€‚è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬çš„ä»£ç å°±ä¸ç”¨ä¿®æ”¹äº†ï¼Œå®ƒå·²ç»æ˜¯å¦‚æ­¤ï¼

å¥½äº†ï¼Œè¯¥å®ç° type ç‰ˆäº†ï¼š
```ts
type ParseStmt<Tokens extends Token[]> =
    Tokens extends Match<TokenLike<'{'>, infer Rest>
        ? ParseBlockStmt<Rest>
        // æ–°å¢å¼€å§‹
        : Tokens extends Match<TokenLike<'if'>, infer Rest>
            ? ParseIfStmt<Rest>
        // æ–°å¢ç»“æŸ
            : ParseExprStmt<Tokens>;

type ParseIfStmt<
    Tokens extends Token[],
> = Tokens extends Match<TokenLike<'('>, infer Rest>
    ? ParseExpr<Rest> extends infer ER
        ? ER extends ParseExprSuccess<infer Condition, infer Rest>
            ? Rest extends Match<TokenLike<')'>, infer Rest>
                ? ParseStmt<Rest> extends infer IfSR
                    ? IfSR extends ParseStmtSuccess<infer IfClause, infer Rest>
                        ? Rest extends Match<TokenLike<'else'>, infer Rest>
                            ? ParseStmt<Rest> extends infer ElseSR
                                ? ElseSR extends ParseStmtSuccess<infer ElseClause, infer Rest>
                                    ? ParseStmtSuccess<BuildIfStmt<Condition, IfClause, ElseClause>, Rest>
                                    : ElseSR // error
                                : NoWay<'ParseIfStmt-ParseStmt-else'>
                            : ParseStmtSuccess<BuildIfStmt<Condition, IfClause, null>, Rest>
                        : IfSR // error
                    : NoWay<'ParseIfStmt-ParseStmt-if'>
                : ParseStmtError<'Expect ")" after if condition.'>
            : ER // error
        : NoWay<'ParseIfStmt-ParseExpr'>
    : ParseStmtError<'Expect "(" before if condition.'>;
```
`ParseIfStmt` çœ‹èµ·æ¥æ˜¯ç›®å‰ type ç‰ˆä¸­æœ€å¤æ‚çš„å‡½æ•°äº†ã€‚ä¸»è¦åŸå› æ˜¯ï¼Œè¯­æ³•ç»†èŠ‚ä¸€æ—¦å¢å¤šï¼Œåœ¨ type ä¸‹æè¿°èµ·æ¥å°±å•°å—¦ã€‚åé¢çš„ `for` å’Œ `fun` æ›´æ˜¯å¦‚æ­¤ã€‚

ç°åœ¨æ¥çœ‹æ‰§è¡Œé˜¶æ®µã€‚ts ç‰ˆä»ç„¶æ˜¯å®ç°å¯¹åº”çš„â€œè®¿é—®â€å‡½æ•°ï¼š
```ts
class Interpreter {
    // ...

    visitIfStmt(stmt: IfStmt): ValueType {
        const cond = stmt.condition.accept(this);
        if (cond) {
            return stmt.ifClause.accept(this);
        } else if (stmt.elseClause) {
            return stmt.elseClause.accept(this);
        }
        return null;
    }

    // ...
}
```
å¾ˆç®€æ´å§ã€‚

ç°åœ¨çœ‹çœ‹ type ç‰ˆï¼š
```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends VarStmt
        ? InterpretVarStmt<S, Env>
        : S extends ExprStmt
            ? InterpretExprStmt<S, Env>
            : S extends BlockStmt
                ? InterpretBlockStmt<S['stmts'], BuildEnv<{}, Env>>
                : S extends IfStmt
                    ? InterpretIfStmt<S, Env>
                    : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;


type InterpretIfStmt<
    S extends IfStmt,
    Env extends Environment,
> = InterpretExpr<S['condition'], Env> extends infer CR
    ? CR extends InterpretExprSuccess<infer C, infer Env>
        ? IsTrue<C> extends true
            ? InterpretStmt<S['ifClause'], Env>
            : S['elseClause'] extends Stmt
                ? InterpretStmt<S['elseClause'], Env>
                : InterpretStmtSuccess<null, Env>
        : CR // error
    : NoWay<'InterpretIfStmt'>;
```
è¿˜å¥½ï¼Œtype ç‰ˆä¹Ÿç®—ç®€æ´ã€‚


##### 2.2.5.8 for è¯­å¥

`for` è¯­å¥æœ‰ç€æ¯” `if` è¯­å¥æ›´å¤šè¯­æ³•ç»†èŠ‚ã€‚è¿™æ„å‘³ç€ï¼Œå®ƒåœ¨è¯­æ³•åˆ†ææ—¶ä¼šæ›´éº»çƒ¦ä¸€äº›ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ç±»å‹å®šä¹‰ï¼š
```ts
class ForStmt implements IStmt {
    type: 'for' = 'for';
    initializer: IStmt | null;
    condition: IExpr | null;
    increment: IExpr | null;
    body: IStmt;

    constructor(
        initializer: IStmt | null,
        condition: IExpr | null,
        increment: IExpr | null,
        body: IStmt) {
        this.initializer = initializer;
        this.condition = condition;
        this.increment = increment;
        this.body = body;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitForStmt(this);
    }
}
```

type ç‰ˆï¼š
```ts
interface ForStmt extends Stmt {
    type: 'for';
    initializer: Stmt | null;
    condition: Expr | null;
    increment: Expr | null;
    body: Stmt;
}

interface BuildForStmt<
    Initializer extends Stmt | null,
    Condition extends Expr | null,
    Increment extends Expr | null,
    Body extends Stmt,
> extends ForStmt {
    initializer: Initializer;
    condition: Condition;
    increment: Increment;
    body: Body;
}
```

æ¥ä¸‹æ¥æ˜¯è¯­æ³•åˆ†æï¼š
```ts
class Parser {
    // ...

    private statement(): IStmt {
        if (this.match('{')) {
            return this.blockStatement();
        } else if (this.match('if')) {
            return this.ifStatement();
        // æ–°å¢å¼€å§‹
        } else if (this.match('for')) {
            return this.forStatement();
        // æ–°å¢ç»“æŸ
        }
        return this.expressionStatement();
    }

    private forStatement() {
        this.consume('(', 'Expect "(" after for keyword.');

        let initializer: IStmt | null;
        if (this.match(';')) {
            initializer = null;
        } else if (this.match('var')) {
            initializer = this.varDeclaration();
        } else {
            initializer = this.expressionStatement();
        }

        let condition: IExpr | null;
        if (this.match(';')) {
            condition = null;
        } else {
            condition = this.expression();
            this.consume(';', 'Expect ";" after for condition.');
        }

        let increment: IExpr | null;
        if (this.match(')')) {
            increment = null;
        } else {
            increment = this.expression();
            this.consume(')', 'Expect ")" after for increment.');
        }

        const body = this.statement();
        return new ForStmt(initializer, condition, increment, body);
    }

    // ...
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªæ¯” `if` è¯­å¥è¦é•¿ä¸€äº›ã€‚å¯ä»¥é¢„è§ type ç‰ˆæœ¬ä¼šæ¯”è¾ƒé•¿ã€‚å¥½åœ¨è¿™é‡Œæ¯”è¾ƒå¥½æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•°ï¼Œè¿™æ ·çœ‹èµ·æ¥ä¸è‡³äºå¾ˆâ€œçˆ†ç‚¸â€ï¼š
```ts
type ParseStmt<Tokens extends Token[]> =
    Tokens extends Match<TokenLike<'{'>, infer Rest>
        ? ParseBlockStmt<Rest>
        : Tokens extends Match<TokenLike<'if'>, infer Rest>
            ? ParseIfStmt<Rest>
            // æ–°å¢å¼€å§‹
            : Tokens extends Match<TokenLike<'for'>, infer Rest>
                ? ParseForStmt<Rest>
                // æ–°å¢ç»“æŸ
                : ParseExprStmt<Tokens>;


type ParseForStmt<
    Tokens extends Token[],
> = Tokens extends Match<TokenLike<'('>, infer Rest>
    ? Rest extends Match<TokenLike<';'>, infer Rest>
        ? ParseForStmtFromCondition<Rest, null>
        : Rest extends Match<TokenLike<'var'>, infer Rest>
            ? ParseForStmtFromInitializerResult<ParseVarStmt<Rest>>
            : ParseForStmtFromInitializerResult<ParseExprStmt<Rest>>
    : ParseStmtError<'Expect "(" after for keyword.'>;

type ParseForStmtFromInitializerResult<IR> =
    IR extends ParseStmtSuccess<infer Initializer, infer Rest>
        ? ParseForStmtFromCondition<Rest, Initializer>
        : IR; // error

type ParseForStmtFromCondition<
    Tokens extends Token[],
    Initializer extends Stmt | null,
> = Tokens extends Match<TokenLike<';'>, infer Rest>
    ? ParseForStmtFromIncrement<Rest, Initializer, null>
    : ParseExpr<Tokens> extends infer CR
        ? CR extends ParseExprSuccess<infer Condition, infer Rest>
            ? Rest extends Match<TokenLike<';'>, infer Rest>
                ? ParseForStmtFromIncrement<Rest, Initializer, Condition>
                : ParseStmtError<'Expect ";" after for condition.'>
            : CR // error
        : NoWay<'ParseForStmtFromCondition'>

type ParseForStmtFromIncrement<
    Tokens extends Token[],
    Initializer extends Stmt | null,
    Condition extends Expr | null,
> = Tokens extends Match<TokenLike<')'>, infer Rest>
    ? ParseForStmtFromBody<Rest, Initializer, Condition, null>
    : ParseExpr<Tokens> extends infer IR
        ? IR extends ParseExprSuccess<infer Increment, infer Rest>
            ? Rest extends Match<TokenLike<')'>, infer Rest>
                ? ParseForStmtFromBody<Rest, Initializer, Condition, Increment>
                : ParseStmtError<'Expect ")" after for increment.'>
            : IR // error
        : NoWay<'ParseForStmtFromIncrement'>;

type ParseForStmtFromBody<
    Tokens extends Token[],
    Initializer extends Stmt | null,
    Condition extends Expr | null,
    Increment extends Expr | null,
    BR = ParseStmt<Tokens>,
> = BR extends ParseStmtSuccess<infer Body, infer Rest>
    ? ParseStmtSuccess<BuildForStmt<Initializer, Condition, Increment, Body>, Rest>
    : BR; // error
```

ç°åœ¨å¼€å§‹ç¼–å†™æ‰§è¡Œä»£ç ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitForStmt(stmt: ForStmt): ValueType {
        const previousEnv = this.environment;
        this.environment = new Environment(this.environment);

        if (stmt.initializer) {
            stmt.initializer.accept(this);
        }

        let conditionResult: ValueType = true;
        if (stmt.condition) {
            conditionResult = stmt.condition.accept(this);
        }

        let result: ValueType = null;
        while (conditionResult) {
            result = stmt.body.accept(this);
            if (stmt.increment) {
                stmt.increment.accept(this);
            }
            if (stmt.condition) {
                conditionResult = stmt.condition.accept(this);
            }
        }

        this.environment = previousEnv;
        return result;
    }

    // ...
}
```
`for` è¯­å¥æœ‰ç±»ä¼¼ `block` è¯­å¥éœ€è¦æ–°å»ºç¯å¢ƒçš„é—®é¢˜ã€‚æ‰€ä»¥åœ¨ type ç‰ˆæœ¬ä¸­ï¼Œè¦æ³¨æ„è¿™æ–¹é¢çš„æ­£ç¡®å¤„ç†ï¼š
```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends VarStmt
        ? InterpretVarStmt<S, Env>
        : S extends ExprStmt
            ? InterpretExprStmt<S, Env>
            : S extends BlockStmt
                ? InterpretBlockStmt<S['stmts'], BuildEnv<{}, Env>>
                : S extends IfStmt
                    ? InterpretIfStmt<S, Env>
                    // æ–°å¢å¼€å§‹
                    : S extends ForStmt
                        ? InterpretForStmt<S, BuildEnv<{}, Env>>
                        // æ–°å¢ç»“æŸ
                        : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;

type InterpretForStmt<
    S extends ForStmt,
    NewEnv extends Environment,
> = S['initializer'] extends Stmt
    ? InterpretStmt<S['initializer'], NewEnv> extends infer IR
        ? IR extends InterpretStmtSuccess<infer IV, infer NewEnv>
            ? InterpretForStmtFromCondition<S, NewEnv>
            : IR // error
        : NoWay<'InterpretForStmt'>
    : InterpretForStmtFromCondition<S, NewEnv>;

type InterpretForStmtFromCondition<
    S extends ForStmt,
    NewEnv extends Environment,
    BV extends ValueType = null,
> = S['condition'] extends Expr
    ? InterpretExpr<S['condition'], NewEnv> extends infer CR
        ? CR extends InterpretExprSuccess<infer CV, infer NewEnv>
            ? InterpretForStmtFromConditionValue<S, NewEnv, CV, BV>
            : CR // error
        : NoWay<'InterpretForStmtFromCondition-InterpretExpr'>
    : InterpretForStmtFromConditionValue<S, NewEnv, true, BV>;

type InterpretForStmtFromConditionValue<
    S extends ForStmt,
    NewEnv extends Environment,
    CV extends ValueType,
    BV extends ValueType = null,
> = IsTrue<CV> extends true
    ?  InterpretStmt<S['body'], NewEnv> extends infer BR
        ? BR extends InterpretStmtSuccess<infer BV, infer NewEnv>
            ? S['increment'] extends Expr
                ? InterpretExpr<S['increment'], NewEnv> extends infer IR
                    ? IR extends InterpretExprSuccess<infer IV, infer NewEnv>
                        ? InterpretForStmtFromCondition<S, NewEnv, BV>
                        : IR // error
                    : NoWay<'InterpretForStmtFromConditionValue-Increment'>
                : InterpretForStmtFromCondition<S, NewEnv, BV>
            : BR // error
        : NoWay<'InterpretForStmtFromConditionValue-Body'>
    : InterpretStmtSuccess<BV, Safe<NewEnv['outer'], Environment>>;
```
å“ˆï¼æˆ‘ä»¬è‰°éš¾çš„å®Œæˆ `for` è¯­å¥ã€‚è‡³æ­¤æˆ‘ä»¬çš„ `Toc` è§£é‡Šå™¨å·²ç»[å›¾çµå®Œå¤‡](https://en.wikipedia.org/wiki/Turing_completeness)äº†ã€‚æ‹¥æœ‰äº†åˆ†æ”¯å’Œå¾ªç¯ï¼Œæˆ‘ä»¬çš„ `Toc` ç¨‹åºä»ç†è®ºä¸Šå°±å¯æ±‚è§£ä»»ä½•[å¯è®¡ç®—é—®é¢˜](https://en.wikipedia.org/wiki/Computable_function)ã€‚ç°å®çš„æƒ…å†µæ˜¯ï¼Œ`ts-toc` çš„ç¡®å¯ä»¥ã€‚ä½† `type-toc` å´ä¸è¡Œã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘åœ¨å‰é¢è®²ç±»å‹ç³»ç»Ÿä¸­çš„é€’å½’æ—¶ï¼Œæåˆ°è¿‡ï¼Œç±»å‹ç³»ç»Ÿä¸­çš„é€’å½’æ˜¯æœ‰æœ€å¤§æ·±åº¦é™åˆ¶çš„ã€‚è¿™æ„å‘³è€…ä¸€ä¸ªæ¯”è¾ƒè€—æ—¶çš„è®¡ç®—é—®é¢˜ï¼Œæ˜¯æ— æ³•åœ¨è¿™ç§æœ‰é™çš„â€œæ—¶é—´â€ä¸‹å®Œæˆçš„ã€‚ç°åœ¨ä½ å¯ä»¥å»è¯•è¯•ï¼Œ`type-toc` å†™çš„ `for` å¾ªç¯èƒ½å¾ªç¯å¤šå°‘æ¬¡ï¼Ÿæˆ‘è‡ªå·±ç¼–å†™äº†ä¸€ä¸ªç®€å•çš„æµ‹è¯•ï¼Œå¦‚ä¸‹ï¼š
```ts
type Result = Toc<`
    var x = 0;
    var i = 1;
    for (; i < 5; i=i+1)
        x = x + i;
`>
```

å½“æˆ‘æŠŠ `i < 5` æ”¹ä¸º `i < 6` å°±ä¼šæç¤ºï¼š

`Type instantiation is excessively deep and possibly infinite.ts(2589)`

ğŸ˜‚ç¡®å®å¾ˆé—æ†¾ï¼ä¸è¿‡æˆ‘ä»¬è‡³å°‘éªŒè¯äº†æˆ‘ä»¬çš„æƒ³æ³•â€”â€”ts çš„ç±»å‹ç³»ç»Ÿæ˜¯å¯ä»¥å®ç°è§£é‡Šå™¨çš„ã€‚æˆ–è®¸åœ¨æœªæ¥ï¼Œéšç€ ts ç¼–è¯‘å™¨çš„ä¸æ–­æ”¹å–„ï¼Œè¿™ç§é™åˆ¶ä¼šé€æ¸å‡å°ã€‚æˆ–è€…ä½œä¸ºçš„è¯»è€…çš„ä½ ï¼Œæœ‰ä»€ä¹ˆå¥½çš„ä¼˜åŒ–æ–¹æ³•èƒ½æ”¹å–„å½“å‰çš„å±€é¢ï¼Œä¹Ÿè¯·éšæ—¶å‘Šè¯‰æˆ‘ï¼Œæˆ‘å¾ˆæƒ³çŸ¥é“ğŸ˜Šï¼

å¥½äº†ï¼Œæˆ‘ä»¬ä¼‘æ•´åï¼Œå°±å‘æœ¬æ¬¡çš„ç»ˆç‚¹â€”â€”å‡½æ•°å‡ºå‘ã€‚


#### 2.2.6 å‡½æ•°

åœ¨æ­¤ä¹‹å‰ï¼Œè™½ç„¶å¯ä»¥é¡ºåˆ©ç¼–å†™ç¨‹åºï¼Œä½†å´æ²¡åŠæ³•å¤ç”¨ä»£ç ã€‚è½¯ä»¶å·¥ç¨‹çš„æ ¸å¿ƒä¹‹ä¸€å°±æ˜¯ [Don't repeat yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)ã€‚æˆ‘æŠŠ `Toc` çš„å‡½æ•°è®¾è®¡æˆ [First-Class-Function](https://en.wikipedia.org/wiki/First-class_function)ï¼Œå¸Œæœ›å®ƒæœ‰è¾ƒå¼ºçš„æŠ½è±¡å’Œè¡¨è¾¾èƒ½åŠ›ã€‚

##### 2.2.6.1 å‡½æ•°è¯­å¥

å’Œå‰é¢ä¸€æ ·ï¼Œæˆ‘ä»¬å…ˆæ¥å®šä¹‰å‡½æ•°è¯­å¥ç±»å‹ï¼š
```ts
class FunStmt implements IStmt {
    type: 'fun' = 'fun';
    name: Token;
    parameters: Token[];
    body: BlockStmt;

    constructor(name: Token, parameters: Token[], body: BlockStmt) {
        this.name = name;
        this.parameters = parameters;
        this.body = body;
    }

    accept<R>(visitor: IStmtVisitor<R>): R {
        return visitor.visitFunStmt(this);
    }
}
```

type ç‰ˆï¼š
```ts
interface FunStmt extends Stmt {
    type: 'fun';
    name: Token;
    parameters: Token[];
    body: BlockStmt;
}

interface BuildFunStmt<
    Name extends Identifier,
    Parameters extends Identifier[],
    Body extends BlockStmt,
> extends FunStmt {
    name: Name;
    parameters: Parameters;
    body: Body;
}
```

æ¥ä¸‹æ¥æ˜¯è¯­æ³•åˆ†æï¼š
```ts
class Parser {
    // ...

    private declaration() {
        if (this.match('var')) {
            return this.varDeclaration();
        } else if (this.match('fun')) {
            return this.funDeclaration();
        }

        return this.statement();
    }

    private funDeclaration() {
        this.consume('identifier', `Expect function name.`);
        const name = this.previous();
        this.consume('(', `Expect '(' after function name.`);
        let params: Token[] = [];
        if (!this.match(')')) {
            params = this.parameters();
            this.consume(')', `Expect ')' after function parameters.`);
        }
        this.consume('{', `Expect '{' before function body.`);
        const body = this.blockStatement();
        return new FunStmt(name, params, body);
    }

    private parameters(): Token[] {
        const params: Token[] = [];
        do {
            this.consume('identifier', 'Expect parameter name.');
            params.push(this.previous());
        } while(this.match(','))
        return params;
    }

    // ...
}
```

type ç‰ˆï¼Œç”±äºå‡½æ•°çš„è¯­æ³•å¤æ‚ä¸€ç‚¹ï¼Œæ‰€ä»¥è¿™é‡Œä»£ç å°±è¦é•¿ä¸å°‘ï¼š
```ts
type ParseDecl<Tokens extends Token[]> =
    Tokens extends Match<TokenLike<'var'>, infer Rest>
        ? ParseVarStmt<Rest>
        // æ–°å¢å¼€å§‹
        : Tokens extends Match<TokenLike<'fun'>, infer Rest>
            ? ParseFunStmt<Rest>
            // æ–°å¢ç»“æŸ
            : ParseStmt<Tokens>;


type ParseFunStmt<
    Tokens extends Token[],
> = Tokens extends Match<infer Name extends Identifier, infer Rest>
    ? ParseFunParams<Rest> extends infer PR
        ? PR extends Match<infer Params extends Identifier[], infer Rest>
            ? Rest extends Match<TokenLike<'{'>, infer Rest>
                ? ParseBlockStmt<Rest> extends infer BR
                    ? BR extends ParseStmtSuccess<infer Body extends BlockStmt, infer Rest>
                        ? ParseStmtSuccess<BuildFunStmt<Name, Params, Body>, Rest>
                        : BR // error
                    : NoWay<'ParseFunStmt-ParseBlockStmt'>
                : PR // error
            : ParseStmtError<`Expect '{' before function body.`>
        : NoWay<'ParseFunStmt-ParseFunParams'>
    : ParseStmtError<`Expect function name, but got: ${Tokens[0]['type']}`>;

type ParseFunParams<
    Tokens extends Token[],
> = Tokens extends Match<TokenLike<'('>, infer Rest>
    ? Rest extends Match<TokenLike<')'>, infer Rest>
        ? [[], ...Rest]
        : ParseFunParamsCore<Rest> extends infer PR
            ? PR extends Match<infer Params extends Identifier[], infer Rest>
                ? Rest extends Match<TokenLike<')'>, infer Rest>
                    ? [Params, ...Rest]
                    : ParseStmtError<`Expect ')', but got: ${Rest[0]['type']}`>
                : PR // error
            : NoWay<'ParseFunParams-ParseFunParamsCore'>
    : ParseStmtError<`Expect '(', but got: ${Tokens[0]['type']}`>;

type ParseFunParamsCore<
    Tokens extends Token[],
    Params extends Identifier[] = [],
> = Tokens extends Match<infer P extends Identifier, infer Rest>
    ? Rest extends Match<TokenLike<','>, infer Rest>
        ? ParseFunParamsCore<Rest, Push<Params, P>>
        : [Push<Params, P>, ...Rest]
    : ParseStmtError<`Expect param name, but got: ${Tokens[0]['type']}`>;
```

è¯¥æ‰§è¡Œé˜¶æ®µäº†ã€‚å‰é¢çš„è¡¨è¾¾å¼è®¡ç®—æˆ–è€…å…¶ä»–è¯­å¥æ‰§è¡Œï¼Œæœ€ç»ˆçš„ç»“æœéƒ½æ˜¯åŸºç¡€æ•°æ®ç±»å‹ã€‚ç°åœ¨å£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆèµ‹ç»™å‡½æ•°åè¿™ä¸ªå˜é‡çš„ï¼Œå°†ä¸å†æ˜¯ä¸€ä¸ªåŸºç¡€ç±»å‹äº†ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°å¯¹è±¡ã€‚è¿™ä¸ªå‡½æ•°å¯¹è±¡åŒ…å«ä»€ä¹ˆå‘¢ï¼Ÿé¦–å…ˆï¼Œå¿…ç„¶åŒ…å«äº† `FunStmt`ï¼Œ å› ä¸º `FunStmt` è®°å½•äº†å‡½æ•°çš„å‚æ•°ã€å‡½æ•°ä½“ï¼Œæ²¡æœ‰è¿™äº›ä¿¡æ¯å°±æ— æ³•åœ¨å‡½æ•°è°ƒç”¨æ—¶æ‰§è¡Œã€‚è¿™æ ·å°±å¤Ÿäº†å—ï¼Ÿæˆ‘ä»¬çš„å‡½æ•°æ”¯æŒé—­åŒ…ï¼Œè¯·çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š
```ts
var inc3;
{
    var n = 3;
    fun inc(x) {
        x + n;
    }
    inc3 = inc;
}

inc3(2);
```
`inc3(2)` æ‰§è¡Œçš„ç»“æœæ˜¯5, å®ƒå…¶å®æ˜¯è°ƒç”¨çš„ `inc` å‡½æ•°ï¼Œ`inc` å‡½æ•°è®°ä½äº†å®ƒæ‰€å¤„ç¯å¢ƒä¸­å˜é‡ `n` çš„å€¼ï¼Œæˆ–è€…è¯´ `inc` å‡½æ•°è®°ä½äº†å®ƒçš„ç¯å¢ƒã€‚æ‰€ä»¥å‡½æ•°å¯¹è±¡è¿˜åº”è¯¥åŒ…å«ä¸€ä¸ªå‡½æ•°æ‰€å¤„çš„ç¯å¢ƒã€‚

```ts
class FunObject {
    private declaration: FunStmt;
    private environment: Environment;

    constructor(declaration: FunStmt, env: Environment) {
        this.declaration = declaration;
        this.environment = env;
    }
}
```

type ç‰ˆï¼š
```ts
type FunObject = {
    declaration: FunStmt;
    environment: Environment;
};

type BuildFunObj<
    D extends FunStmt,
    E extends Environment,
> = {
    declaration: D,
    environment: E,
};
```

`FunObject` å·²ç»å®šä¹‰å‡ºæ¥äº†ã€‚ä½†æ˜¯è¿˜æœ‰ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åˆšè¯´è¿™ä¸ªå¯¹è±¡è¦èµ‹ç»™å˜é‡ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¿®æ”¹ `ValueType` äº†ï¼Œå°±æ˜¯è¯´å˜é‡çš„å€¼ç±»å‹å¢åŠ äº†ï¼Œè¡¨è¾¾å¼ä¸­ä¹Ÿå¯ä»¥åŒ…å«å‡½æ•°å¯¹è±¡ç±»å‹æ¥è¿ç®—äº†ï¼š
```ts
type ValueType =
    | FunObject
    | string
    | number
    | boolean
    | null;
```
è¿™æ ·å’Œ `literal` æœ‰å…³çš„ä¸¤ä¸ªåœ°æ–¹éœ€è¦ä¿®æ”¹ï¼Œä¸‹é¢åªåˆ—ä¸¾ ts ç‰ˆï¼š
```ts
class LiteralExpr implements IExpr {
    type: ExprType = 'literal';
    value: Exclude<ValueType, FunObject>; // ä¿®æ”¹

    constructor(value: Exclude<ValueType, FunObject>) { // ä¿®æ”¹
        this.value = value;
    }
}

class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitLiteralExpr(expr: LiteralExpr): Exclude<ValueType, FunObject> { // ä¿®æ”¹
        return expr.value;
    }

    // ...
}
```

å¥½äº†ï¼Œç°åœ¨æˆ‘ä»¬æ¥å®ç° `visitFunStmt` å‡½æ•°ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitFunStmt(stmt: FunStmt): FunObject {
        const funObj = new FunObject(stmt, this.environment);
        this.environment.define(stmt.name, funObj);
        return funObj;
    }

    // ...
}
```
æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼åœ¨æ¥çœ‹ type ç‰ˆï¼š

```ts
type InterpretStmt<S extends Stmt, Env extends Environment> =
    S extends VarStmt
        ? InterpretVarStmt<S, Env>
        : S extends ExprStmt
            ? InterpretExprStmt<S, Env>
            : S extends BlockStmt
                ? InterpretBlockStmt<S['stmts'], BuildEnv<{}, Env>>
                : S extends IfStmt
                    ? InterpretIfStmt<S, Env>
                    // æ–°å¢å¼€å§‹
                    : S extends FunStmt
                        ? InterpretFunStmt<S, Env>
                        // æ–°å¢ç»“æŸ
                        : S extends ForStmt
                            ? InterpretForStmt<S, BuildEnv<{}, Env>>
                            : InterpretStmtError<`Unsupported statement type: ${S['type']}`>;

type InterpretFunStmt<
    S extends FunStmt,
    Env extends Environment,
    F extends FunObject = BuildFunObj<S, Env>,
> = EnvDefine<Env, S['name']['lexeme'], F> extends infer NewEnv
    ? NewEnv extends Environment
        ? InterpretStmtSuccess<F, NewEnv>
        : NewEnv // error
    : NoWay<'InterpretFunStmt'>;
```
ä¹Ÿå¾ˆç®€å•å¯¹ä¸å¯¹ï¼

ä¸è¿‡è¿˜æœ‰ä¸ªé—®é¢˜ï¼Œè¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š
```ts
fun a() {}
a; // è¿™é‡Œè¾“å‡ºä»€ä¹ˆå‘¢ï¼Ÿ
```
ä½ æˆ–è®¸è¯´è¾“å‡ºå‡½æ•°å¯¹è±¡å‘€ï¼æ˜¯çš„æ²¡é”™ã€‚ä½†æ˜¯ç»™äººâ€œçœ‹â€è¿™ä¸ªå¯¹è±¡ææ€•ä¸å¤ªå¥½ï¼Œéœ€è¦æ˜¾ç¤ºæˆä¸€ä¸ªä¾¿äºäººé˜…è¯»çš„å½¢å¼ã€‚æ‰€ä»¥è¦æ·»åŠ ä¸€ä¸ª `toString` çš„å‡½æ•°ï¼Œç”¨æ¥æ˜¾ç¤ºè¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼ŒåŒ…å«å®ƒçš„åå­—å’Œå‚æ•°ååˆ—è¡¨ã€‚
```ts
class FunObject {
    // ...

    toString() {
        const { name, parameters } = this.declaration;
        const params = parameters.map(t => t.lexeme).join(', ');
        return `<fun ${name.lexeme}(${params})>`;
    }
}
```
è¿™æ ·ä»¥åï¼Œ ts-toc è¾“å‡ºåˆ°æ§åˆ¶å°æ—¶ï¼Œå°±ä¼šè‡ªåŠ¨è°ƒç”¨ `toString` æ–¹æ³•ã€‚

å†æ¥çœ‹çœ‹ type ç‰ˆï¼Œä¹Ÿæ˜¯æ·»åŠ ä¸€ä¸ª `toString` æ–¹æ³•ï¼š
```ts
type FunObjToString<
    F extends FunObject,
    D extends FunStmt = F['declaration']
> = `<fun ${GetFunName<F>}(${ParamsToString<D['parameters']>})>`;

type GetFunName<F extends FunObject> = F['declaration']['name']['lexeme'];

type ParamsToString<
    Params extends Token[],
    Result extends string = '',
> = Params extends [infer T extends Token, ...infer R extends Token[]]
    ? ParamsToString<R, Combine<Result, T['lexeme']>>
    : Result;
type Combine<
    A extends string,
    B extends string,
> = A extends ''
    ? B
    : `${A}, ${B}`;
```
è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œtype-toc å¹¶ä¸ä¼šè‡ªåŠ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¿®æ”¹ `Toc` å‡½æ•°ï¼š
```ts
type Toc<Source extends string> =
    Scan<Source> extends infer Tokens
        ? Tokens extends Token[]
            ? Parse<Tokens> extends infer Stmts
                ? Stmts extends Stmt[]
                    // ä¿®æ”¹å¼€å§‹
                    ? Interpret<Stmts> extends infer Value
                        ? Value extends FunObject
                            ? FunObjToString<Value>
                            : Value
                        : NoWay<'Toc-Interprets'>
                        // ä¿®æ”¹ç»“æŸ
                    : Stmts // error
                : NoWay<'Toc-Parse'>
            : Tokens // error
        : NoWay<'Toc-Scan'>;
```

å¥½äº†ï¼Œä»¥ä¸Šæˆ‘ä»¬å°±å®Œæˆäº†å‡½æ•°çš„å£°æ˜è¯­å¥ã€‚ç°åœ¨è¿˜å·®æœ€åä¸€æ­¥â€”â€”å‡½æ•°è°ƒç”¨ã€‚å‡½æ•°è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ¥ä¸‹æ¥å°±æ¥å¤„ç†å®ƒã€‚


##### 2.2.6.2 call è¡¨è¾¾å¼

è¦æ”¯æŒå‡½æ•°è¡¨è¾¾å¼ï¼Œé¦–å…ˆè¦åŠ å…¥è¿™ä¸ªç±»å‹ï¼š
```ts
type ExprType =
    // ...
    | 'call'; // <-- æ–°å¢
```

å‡½æ•°è°ƒç”¨æ—¶ï¼Œä¸»è¦æœ‰è¢«è°ƒç”¨è€…å’Œå‡½æ•°å‚æ•°ï¼ˆå½“ç„¶å¯ç©ºï¼‰ã€‚ä¾æ­¤æˆ‘ä»¬å®šä¹‰è¡¨è¾¾å¼ç±»å‹ï¼š
```ts
class CallExpr implements IExpr {
    type: ExprType = 'call';
    callee: IExpr;
    args: IExpr[];

    constructor(callee: IExpr, args: IExpr[]) {
        this.callee = callee;
        this.args = args;
    }

    accept<R>(visitor: IExprVisitor<R>): R {
        return visitor.visitCallExpr(this);
    }
}
```

type ç‰ˆï¼š
```ts
interface CallExpr extends Expr {
    type: 'call';
    callee: Expr;
    arguments: Expr[];
}

interface BuildCallExpr<Callee extends Expr, Args extends Expr[]> extends CallExpr {
    callee: Callee;
    arguments: Args;
}
```

æ¥ä¸‹æ¥æˆ‘ä»¬æŠŠå‡½æ•°è°ƒç”¨åŠ å…¥åˆ°è¡¨è¾¾å¼ä¼˜å…ˆçº§åˆ—è¡¨ä¸­ï¼š
```ts
// è¡¨è¾¾å¼æŒ‰ç…§ä¼˜å…ˆçº§ç”±ä½åˆ°é«˜ï¼š
// logic or:    ||                  å·¦ç»“åˆ
// logic and:   &&                  å·¦ç»“åˆ
// equality:    == !=               å·¦ç»“åˆ
// relation:    < > <= >=           å·¦ç»“åˆ
// additive:    + -                 å·¦ç»“åˆ
// factor:      * / %               å·¦ç»“åˆ
// unary:       !                   å³ç»“åˆ
// call:        primary(arg?)       å·¦ç»“åˆ        ã€ˆ=== æ–°å¢
// primary:     literal group
```

æœ‰äº†å®ƒï¼Œæˆ‘å°±å¯ä»¥å¼€å§‹å†™è¯­æ³•åˆ†æçš„å¥—è·¯ä»£ç ï¼š
```ts
class Parser {
    // ...

    private unary(): IExpr {
        if (this.match('!')) {
            const operator = this.previous();
            const expr = this.unary(); // å³ç»“åˆ
            return new UnaryExpr(operator, expr);
        }
        return this.call(); // æ›¿æ¢ä¸€è¡Œ
    }

    private call(): IExpr {
        let expr = this.primary();
        while (this.match('(')) {
            let args: IExpr[] = [];
            if (!this.match(')')) {
                args = this.arguments();
                this.consume(')', 'Expect ")" end fun call.');
            }
            expr = new CallExpr(expr, args);
        }
        return expr;
    }

    private arguments(): IExpr[] {
        const args: IExpr[] = [];
        do {
            args.push(this.expression());
        } while(this.match(','));
        return args;
    }

    // ...
}
```

ä¸‹é¢æ˜¯ type ç‰ˆï¼š
```ts
type ParseCall<Tokens extends Token[], CR = ParsePrimary<Tokens>> =
    CR extends ParseExprSuccess<infer Callee, infer Rest>
        ? Rest extends Match<TokenLike<'('>, infer Rest>
            ? Rest extends Match<TokenLike<')'>, infer Rest>
                ? ParseCall<Rest, ParseExprSuccess<BuildCallExpr<Callee, []>, Rest>>
                : ParseArgs<Rest> extends infer AR
                    ? AR extends ParseArgsSuccess<infer Args, infer Rest>
                        ? Rest extends Match<TokenLike<')'>, infer Rest>
                            ? ParseCall<Rest, ParseExprSuccess<BuildCallExpr<Callee, Args>, Rest>>
                            : ParseExprError<'Expect ")" after call.'>
                        : AR // error
                    : NoWay<'ParseCall-ParseArgs'>
            : CR // not match more '('
        : CR; // error

type ParseArgsSuccess<R extends Expr[], T extends Token[]> = SuccessResult<{ args: R, rest: T }>;
type ParseArgs<Tokens extends Token[], Args extends Expr[] = []> =
    ParseExpr<Tokens> extends infer AE
        ? AE extends ParseExprSuccess<infer Arg, infer Rest>
            ? Rest extends Match<TokenLike<','>, infer Rest>
                ? ParseArgs<Rest, Push<Args, Arg>>
                : ParseArgsSuccess<Push<Args, Arg>, Rest>
            : AE // error
        : NoWay<'ParseArgs-ParseExpr'>;
```

ä¸‹é¢è¯¥å¤„ç†æ‰§è¡Œäº†ã€‚`call` è¡¨è¾¾å¼æ‰§è¡Œæ—¶ï¼Œå…ˆè¦å¯¹å‚æ•°è¿›è¡Œæ±‚å€¼ï¼Œå› ä¸ºå‚æ•°ä¹Ÿæ˜¯è¡¨è¾¾å¼ã€‚å‚æ•°æ±‚å€¼çš„è¿‡ç¨‹ä¸­ï¼Œç¯å¢ƒæ˜¯ `call` è¡¨è¾¾å¼æ‰€å¤„çš„ç¯å¢ƒã€‚å‡½æ•°ä½“æ‰§è¡Œçš„æ—¶å€™ï¼Œæ–°å»ºäº†ä¸€ä¸ªç¯å¢ƒã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªæ–°å»ºç¯å¢ƒçš„å¤–éƒ¨ç¯å¢ƒä¸æ˜¯ `call` è¡¨è¾¾å¼æ‰€å¤„çš„ç¯å¢ƒï¼Œè€Œæ˜¯å‡½æ•°å¯¹è±¡ç”Ÿæˆæ—¶æ‰€å¤„çš„ç¯å¢ƒã€‚è¿™ä¸ªç¯å¢ƒå­˜å‚¨åœ¨å‡½æ•°å¯¹è±¡ä¸­ã€‚å¦å¤–å®å‚ä¸å½¢å‚çš„ç»‘å®šï¼Œå°±æ˜¯åœ¨æ–°ç¯å¢ƒä¸­ã€‚å³æŒ‰ç…§å½¢å‚åˆ—è¡¨æ¥å®šä¹‰å˜é‡ï¼Œå˜é‡çš„å€¼æ˜¯å®å‚çš„å€¼ã€‚å‡½æ•°ä½“æ‰§è¡Œå®Œæˆä¹‹åï¼Œç¯å¢ƒè¦å›åˆ° `call` è¡¨è¾¾å¼æ‰€å¤„çš„ç¯å¢ƒã€‚

å‡½æ•°ä½“æ‰§è¡Œçš„ä»£ç å’Œå—è¯­å¥æ‰§è¡Œçš„ä»£ç é«˜åº¦ç›¸ä¼¼ï¼Œæ‰€ä»¥æŠ½å‡ºä¸€ä¸ª `executeBlock` å‡½æ•°æ¥å¤ç”¨ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitBlockStmt(blockStmt: BlockStmt): ValueType {
        const result = this.executeBlock(blockStmt, new Environment(this.environment));
        return result;
    }

    executeBlock(blockStmt: BlockStmt, env: Environment): ValueType {
        const previousEnv = this.environment;

        try {
            this.environment = env;

            let lastResult: ValueType = null;
            for (const stmt of blockStmt.stmts) {
                lastResult = stmt.accept(this);
            }
            return lastResult;
        } finally {
            this.environment = previousEnv;
        }
    }

    // ...
}
```

å¦å¤–æˆ‘ä»¬æŠŠå‡½æ•°æ‰§è¡Œçš„æ ¸å¿ƒä»£ç æŠ½ä¸€ä¸ªå‡½æ•° `execute`ï¼Œ æ”¾åˆ° `FunObject` ä¸­å»ï¼Œè¿™æ · `visitFunStmt` å°±å¾ˆç®€å•äº†ï¼š
```ts
class Interpreter implements IExprVisitor<unknown>, IStmtVisitor<unknown> {
    // ...

    visitCallExpr(expr: CallExpr): ValueType {
        const callee = expr.callee.accept(this);

        // åªæœ‰å‡½æ•°å¯¹è±¡æ‰èƒ½è¢«è°ƒç”¨
        if (callee instanceof FunObject) {
            return callee.execute(expr.args, this);
        }

        throw new RuntimeError(`Callee must be a 'FunObject', but got: ${callee}(${typeof callee})`);
    }

    // ...
}
```

æœ€åæˆ‘ä»¬çœ‹çœ‹ `execute` çš„å®ç°ï¼š
```ts
class FunObject {
    // ...

    execute(args: IExpr[], interpreter: Interpreter): ValueType {
        if (args.length !== this.declaration.parameters.length) {
            throw new RuntimeError('Arguments length not match parameters.');
        }

        const env = new Environment(this.environment);
        const parameters = this.declaration.parameters;
        for (let i = 0; i < args.length; i++) {
            const argValue = args[i].accept(interpreter);
            const param = parameters[i];
            env.define(param, argValue);
        }

        return interpreter.executeBlock(this.declaration.body, env);
    }

    // ...
}
```

ä»¥ä¸Šï¼Œts-toc å°±å®Œæˆäº†ã€‚

ä¸‹é¢æ¥çœ‹ type ç‰ˆ, å…ˆè¦ä¿®æ”¹ `InterpretExpr`:
```ts
type InterpretExpr<E extends Expr, Env extends Environment> =
                        // ...
                        : E extends AssignExpr
                            ? EvalAssignExpr<E, Env>
                            // æ–°å¢å¼€å§‹
                            : E extends CallExpr
                                ? EvalCallExpr<E, Env>
                                // æ–°å¢ç»“æŸ
                                : RuntimeError<`Unknown expression type: ${E['type']}`>;

```
`EvalCallExpr` å‡½æ•°çš„å®ç°å¹¶ä¸å®¹æ˜“ï¼Œç‰¹åˆ«æ˜¯ç¯å¢ƒçš„å¤„ç†ï¼š
```ts
type EvalCallExpr<
    E extends CallExpr,
    Env extends Environment,
    CV = InterpretExpr<E['callee'], Env>
> = CV extends InterpretExprSuccess<infer Callee, infer Env>
    ? Callee extends FunObject
        ? GetParamsLength<Callee> extends E['arguments']['length']
            ? InjectArgsToEnv<GetParams<Callee>, E['arguments'], Env, BuildEnv<{}, Callee['environment']>> extends infer EE
                ? EE extends InjectArgsToEnvSuccess<infer CallerEnv, infer FunScopeEnv>
                    ? InterpretBlockStmt<GetBodyStmts<Callee>, FunScopeEnv> extends infer BR
                        ? BR extends InterpretStmtSuccess<infer BV, infer Env>
                            ? InterpretStmtSuccess<BV, CallerEnv> // å‡½æ•°bodyæ‰§è¡Œå®Œè¦å›åˆ°CallerEnv
                            : BR // error
                        : NoWay<'EvalCallExpr-InterpretBlockStmt'>
                    : EE // error
                : NoWay<'EvalCallExpr-InjectArgsToEnv'>
            : RuntimeError<'Arguments length not match parameters.'>
        : RuntimeError<`Callee must be a 'FunObject', but got: ${Safe<Callee, Exclude<ValueType, FunObject>>}`>
    : CV; // error

type GetParams<Callee extends FunObject> = Callee['declaration']['parameters'];
type GetParamsLength<Callee extends FunObject> = GetParams<Callee>['length'];
type GetBodyStmts<Callee extends FunObject> = Callee['declaration']['body']['stmts'];
```
å…¶ä¸­è¦æ³¨æ„çš„ä¸ä»…æœ‰æ³¨é‡Šå†™çš„ "å‡½æ•°bodyæ‰§è¡Œå®Œè¦å›åˆ°CallerEnv"ã€‚è¿˜è¦æ³¨æ„åˆ°æœ€ç»ˆè¦è¿”å›çš„ `CallerEnv` æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿå®ƒæ˜¯ä» `InjectArgsToEnv` å‡½æ•°æ‰§è¡Œçš„ç»“æœä¸­æ‹¿åˆ°çš„ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå‰é¢è¯´è¿‡ï¼Œtype ä¸­æ²¡æœ‰å˜é‡ï¼Œæˆ‘ä»¬ä¸èƒ½åƒ ts ç‰ˆä¸­ï¼Œä¿ç•™ä¸€ä¸ªå¼•ç”¨å°±å¯ä»¥äº†ã€‚ç¯å¢ƒåœ¨å‘ç”Ÿå˜åŒ–åï¼Œæ€»æ˜¯äº§ç”Ÿä¸€ä¸ªæ–°çš„å€¼ã€‚å‡½æ•°çš„å®å‚æ˜¯åœ¨ `InjectArgsToEnv` ä¸­æ±‚å€¼çš„ï¼Œæ±‚å€¼è¿‡ç¨‹ä¸­æœ‰å¯èƒ½ä¿®æ”¹ `CallerEnv`ï¼Œæ‰€ä»¥è¦è¿”å›å®ƒã€‚ä¸ºä»€ä¹ˆæœ‰å¯èƒ½ä¿®æ”¹ `CallerEnv`ï¼Ÿå› ä¸ºå®å‚ä¸­çš„è¡¨è¾¾å¼æœ‰å¯èƒ½åŒ…å«èµ‹å€¼è¡¨è¾¾å¼ã€‚`InjectArgsToEnv` è¿”å›çš„å¦ä¸€ä¸ªç¯å¢ƒæ˜¯ `FunScopeEnv`ï¼Œè¿™ä¸ªæ­£æ˜¯å‡½æ•°ä½“æ‰§è¡Œéœ€è¦çš„ç¯å¢ƒï¼Œå®ƒé‡Œé¢åŒ…å«äº†å½¢å‚å˜é‡å¯¹åº”çš„å€¼ï¼ˆå®å‚ï¼‰ã€‚
```ts

type InjectArgsToEnv<
    Params extends Token[],
    Args extends Expr[],
    CallerEnv extends Environment,
    FunScopeEnv extends Environment,
> = Params extends [infer P1 extends TokenLike<{ type: 'identifier'}>, ...infer RestParams extends Token[]]
        ? Args extends [infer A1 extends Expr, ...infer RestArgs extends Expr[]]
            ? InterpretExpr<A1, CallerEnv> extends infer PV
                ? PV extends InterpretExprSuccess<infer V, infer CallerEnv>
                    ? EnvDefine<FunScopeEnv, P1['lexeme'], V> extends infer FunScopeEnv
                        ? FunScopeEnv extends Environment
                            ? InjectArgsToEnv<RestParams, RestArgs, CallerEnv, FunScopeEnv>
                            : FunScopeEnv // error
                        : NoWay<'InjectArgsToEnv-EnvDefine'>
                    : PV // error
                : NoWay<'InjectArgsToEnv-InterpretExpr'>
            : RuntimeError<'No way here, params and args must match here!'>
        : InjectArgsToEnvSuccess<CallerEnv, FunScopeEnv>;
type InjectArgsToEnvSuccess<
    CallerEnv extends Environment,
    FunScopeEnv extends Environment,
> = SuccessResult<{ callerEnv: CallerEnv, funScopeEnv: FunScopeEnv }>;
```

ä»¥ä¸Šæˆ‘ä»¬å®Œæˆäº†å‡½æ•°è°ƒç”¨ï¼ä½†æ˜¯å¦‚æœä½ ç”¨ä¸‹é¢çš„ä»£ç å»æ£€éªŒï¼Œå´å‘ç°æ— æ³•å¾—åˆ°æœŸå¾…çš„ç»“æœï¼š
```ts
fun fib(n) {
    if (n >= 2) {
        fib(n - 1) + fib(n - 2);
    } else {
        1;
    }
}

fib(3);
```
å®ƒå¹¶ä¸æ˜¯æç¤ºï¼š `Type instantiation is excessively deep and possibly infinite.`

å®ƒçš„è¾“å‡ºæ˜¯ï¼š `[RuntimeError]: Undefined variable 'fib'."`

ğŸ¤”â“æ€ä¹ˆä¼šè¿™æ ·ï¼Ÿå¦‚æœä½ å¤šæ¬¡å®éªŒï¼Œä½ ä¼šå‘ç°ï¼Œæˆ‘ä»¬å®ç°çš„ `type-toc` æ— æ³•æ”¯æŒå‡½æ•°é€’å½’ï¼ï¼é—®é¢˜å‡ºåœ¨å“ªé‡Œå‘¢ï¼Ÿ

é—®é¢˜å‡ºåœ¨ `FunScopeEnv` ä¸Šï¼Œå®ƒé‡Œé¢æ²¡æœ‰åŒ…å« `fib` å˜é‡ã€‚æ‰€ä»¥é€’å½’çš„æ—¶å€™æ‰¾ä¸åˆ°è‡ªå·±ã€‚ä¸ºä»€ä¹ˆä¼šä¸åŒ…å«è‡ªå·±å‘¢ï¼Ÿæˆ‘ä»¬å›åˆ°å‡½æ•°å£°æ˜çš„æ‰§è¡Œå‡½æ•°ï¼š
```ts
type InterpretFunStmt<
    S extends FunStmt,
    Env extends Environment,
    F extends FunObject = BuildFunObj<S, Env>, // <--è¿™é‡Œæ„å»ºäº† FunObject, è¿™é‡Œçš„ Env æ²¡æœ‰åŒ…å«å‡½æ•°å¯¹åº”çš„å˜é‡
> = EnvDefine<Env, S['name']['lexeme'], F> extends infer NewEnv // <--è¿™é‡Œç”¨æ„å»ºå¥½çš„ FunObject äº§ç”Ÿäº†æ–°çš„ç¯å¢ƒ
    ? NewEnv extends Environment
        ? InterpretStmtSuccess<F, NewEnv>
        : NewEnv // error
    : NoWay<'InterpretFunStmt'>;
```
é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªé—®é¢˜ä¼¼ä¹æ— è§£ï¼šæ„å»ºå‡½æ•°éœ€è¦ä¸€ä¸ªåŒ…å«è¯¥å‡½æ•°çš„ Env ã€‚æ²¡æœ‰å˜é‡çš„ç¡®æ˜¯åšä¸åˆ°çš„ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆç›¸åŒçš„ä»£ç ï¼Œ`ts-toc` æ²¡æœ‰è¿™ä¸ªé—®é¢˜ã€‚è¯´åˆ°è¿™é‡Œï¼Œ`ts-toc` å’Œ `type-toc` åœ¨è¿™é‡Œæœ‰è¾ƒå¤§çš„å·®å¼‚ï¼Œä¸ä»…ä»…æ˜¯ `type-toc` æ— æ³•é€’å½’ã€‚è¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š
```ts
var a = 1;
fun test() { a + b; }
var b = 10;
test();
```
è¿™æ®µä»£ç ï¼Œ`ts-toc` æ‰§è¡Œçš„ç»“æœæ˜¯ 11ï¼›è€Œ `type-toc` æŠ¥é”™è¯´ `[RuntimeError]: Undefined variable 'b'."`ã€‚ä»è¿™ä¸ªè¡Œä¸ºæ¥çœ‹ä¹Ÿä¸èƒ½è¯´è°å¯¹è°é”™ï¼Œå…³é”®å–å†³äºè¯­è¨€è®¾è®¡è€…å¸Œæœ›æ˜¯å“ªä¸ªç»“æœã€‚ç±»ä¼¼ä¸Šé¢çš„ä»£ç åœ¨ `js` ä¸­ä¼šå¾—åˆ°å’Œ `ts-toc` ä¸€æ ·çš„[ç»“æœ](https://www.typescriptlang.org/play?#code/DYUwLgBAhhC8EEYDcAoAZgVwHYGMwEsB7LCMEAZzAAoBKCAbwgCdwMmSYBqCAIyQgC+KUJB5xEABlQ5i5QqAB0wQgHMqZSrRpIgA)ï¼›ä½†åœ¨ `C#` ä¸­å´æ˜¯ç±»ä¼¼ `type-toc` çš„[ç»“æœ](https://dotnetfiddle.net/TAPdr5)ã€‚

æˆ‘åœ¨è¿™é‡Œæ›´å€¾å‘äº `type-toc` çš„è¡Œä¸ºã€‚å› ä¸ºè¿™æ ·çš„ä»£ç æ›´å¥½ç†è§£å’Œç»´æŠ¤ã€‚ä½†æˆ‘ä¸æ‰“ç®—å¤„ç† `ts-toc` åœ¨è¿™é‡Œçš„ä¸ä¸€è‡´ğŸ˜‚ã€‚æˆ‘ä»¬è¿˜æ˜¯å›åˆ° `type-toc` æ— æ³•é€’å½’çš„é—®é¢˜ä¸Šã€‚çœŸçš„å°±å®ç°ä¸äº†é€’å½’äº†å—ï¼Ÿ

å…¶å®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ‰§è¡Œè¿™è¾¹ä¸‹åŠŸå¤«ã€‚æ‰§è¡Œå‡½æ•°ä½“çš„æ—¶å€™ï¼Œ`FunScopeEnv` "æ³¨å…¥"äº†å‡½æ•°çš„å‚æ•°å˜é‡ã€‚æˆ‘ä»¬åœ¨è¿™ä¸ªæ—¶å€™æ³¨å…¥å‡½æ•°å˜é‡ä¸è¡Œå—ï¼Ÿå½“ç„¶æ˜¯å¯ä»¥çš„ã€‚æˆ‘ä»¬åªéœ€è¦å°†ä¸‹é¢è¿™å¥

```ts
? InjectArgsToEnv<GetParams<Callee>, E['arguments'], Env, BuildEnv<{}, Callee['environment']>> extends infer EE
```

æ›¿æ¢ä¸º
```ts
? InjectArgsToEnv<GetParams<Callee>, E['arguments'], Env, BuildEnv<{ [k in GetFunName<Callee>]: Callee }, Callee['environment']>> extends infer EE
```

å…³é”®å°±æ˜¯ï¼š
```ts
BuildEnv<{ [k in GetFunName<Callee>]: Callee }, Callee['environment']>
```

åœ¨æ„å»ºå‡½æ•°ä½“æ‰§è¡Œç¯å¢ƒæ—¶ï¼Œç›´æ¥å°†å‡½æ•°çš„å˜é‡ç»‘å®šè¿›å»ã€‚

çš„ç¡®ï¼Œè¿™æ ·å°±å®ç°äº†é€’å½’ã€‚å¯æ˜¯æ”¹æˆè¿™æ ·ä»¥åï¼Œå†™å¾ˆå¤šç®€å•ä¸”ä¸é€’å½’çš„å‡½æ•°éƒ½ä¼šå‡ºç° `Type instantiation is excessively deep and possibly infinite.`ï¼Œæ›´åˆ«è¯´é€’å½’çš„å‡½æ•°äº†ã€‚å»æ‰é€’å½’æ”¯æŒåè¿™äº›ç®€å•ä¸é€’å½’çš„å‡½æ•°åˆéƒ½èƒ½æ­£å¸¸æ‰§è¡Œäº†ã€‚æˆ‘å°è¯•äº†å¤šç§ä¿®æ”¹æ¥æ”¯æŒé€’å½’ï¼Œå¾—åˆ°çš„æ•ˆæœä¸€æ ·ã€‚æ‰€ä»¥æœ€ååœ¨ `toc` ä»“åº“çš„[ä»£ç ](https://github.com/huanguolin/toc/blob/9acb2e989a861620346d19d4b0f1779000ff0ccf/type-toc/interpreter/InterpretExpr.d.ts#L42)ä¸­ï¼Œæˆ‘æŠŠæ”¯æŒé€’å½’çš„ä»£ç æ³¨é‡Šæ‰äº†ã€‚å¦‚æœä½ çŸ¥é“æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¯·åŠ¡å¿…å‘Šè¯‰æˆ‘ï¼Œæˆ–è€…ç›´æ¥æ `pr`ã€‚

å¥½äº†ï¼Œè™½ç„¶æœ‰äº›è®¸é—æ†¾ï¼Œä½†æˆ‘ä»¬æœ€ç»ˆå®Œæˆäº†è¿™ä¸ªè‰°éš¾çš„ä»»åŠ¡ã€‚æˆ‘ä»¬ç”¨ TypeScript çš„ç±»å‹ç³»ç»ŸæˆåŠŸå®ç°äº†ä¸€ä¸ª Toc è¯­è¨€çš„è§£é‡Šå™¨ï¼è¿™ä¸ªç±»å‹ä½“æ“ç»ˆäºè°¢å¹•ï¼Œè°¢è°¢ï¼

#### 2.2.7 æœªå°½äº‹å®œ

åˆ°æœ€åï¼Œæˆ‘ä»¬ä¸ä»…æœ‰é€’å½’æ— æ³•è‰¯å¥½æ”¯æŒçš„é—æ†¾ã€‚è¿˜æœ‰ä¸€äº›å…¶ä»–çš„æœªå°½äº‹å®œã€‚æ¯”å¦‚ï¼Œå‡½æ•°æ²¡æœ‰ `return` è¯­å¥çš„æ”¯æŒï¼Œå¾ªç¯ä¹Ÿä¸æ”¯æŒ `break`ã€‚å¦‚æœè¦è®©è¿™ä¸ªè¯­è¨€æ›´å®Œå–„ï¼Œè¿™æ˜¯ä¸€å®šè¦æ”¯æŒçš„ã€‚å¦åˆ™æ— æ³•æå‰ç»“æŸå‡½æ•°ï¼Œæˆ–è€…å¾ªç¯ï¼Œåªèƒ½é æ¡ä»¶åˆ†æ”¯æ¥ç»•ï¼Œä¼šå¾ˆç—›è‹¦ã€‚å®ƒä»¬æ˜¯å¯ä»¥å®ç°çš„ï¼Œå°±æ˜¯éº»çƒ¦ï¼Œéœ€è¦åƒç¯å¢ƒä¸€æ ·åˆ°å¤„éƒ½å¸¦ç€ï¼Œè¿˜è¦åœ¨ä¸€äº›å…³é”®è·¯å¾„å»åˆ¤æ–­ã€‚

å¦å¤–å¯¹é”™è¯¯çš„æ”¯æŒä¹Ÿå¾ˆç²—ç•¥ï¼Œè¿è¡Œå·ä¿¡æ¯ä¹Ÿæ²¡æœ‰ï¼Œç¨‹åºé•¿ä¸€ç‚¹ï¼Œå°±ä¸å¥½æ‰¾åˆ°é”™è¯¯äº†ã€‚è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯ï¼Œæ²¡æœ‰å¤åˆæ•°æ®ç±»å‹ï¼Œæ²¡æœ‰å¯¹è±¡ï¼ˆæˆ–è€…è‡³å°‘æœ‰ä¸ª `struct`ï¼‰ï¼Œæ•°ç»„è¿™äº›ç°ä»£è¯­è¨€çš„å¿…é¡»å“ã€‚ä¸è¿‡ä½œä¸ºä¸€æ¬¡å°è¯•ï¼Œä»¥ç°åœ¨çš„ç»“æœå¯ä»¥è¯´æ˜é—®é¢˜å°±å¯ä»¥ã€‚è‹¥çœŸçš„è¦è‡ªå·±å®ç°ä¸€ä¸ªå¯ç©çš„è¯­è¨€ï¼Œåº”è¯¥ä¸è¦é€‰æ‹© TypeScript çš„ç±»å‹ç³»ç»Ÿ ğŸ˜‚ã€‚

å¥½äº†ï¼Œå¦‚æœä½ æ„Ÿå…´è¶£å»å®ç°è¿™äº›ï¼Œæ¬¢è¿æ `pr`ã€‚


## 3. æ€»ç»“

æœ€åï¼Œæˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹ã€‚
é¦–å…ˆæˆ‘ä»¬å›´ç»•ç€ TypeScript çš„ç±»å‹ç³»ç»Ÿæ˜¯ä¸€é—¨å‡½æ•°å¼è¯­è¨€ï¼Œè®¨è®ºäº†å®ƒæä¾›çš„è¯­è¨€ç‰¹æ€§ï¼š

* æ²¡æœ‰å˜é‡ï¼Œæœ‰å…¨å±€å¸¸é‡å’Œå±€éƒ¨å¸¸é‡ã€‚
* æœ‰æ¡ä»¶åˆ†æ”¯ï¼Œè¿˜æœ‰æ¨¡å¼åŒ¹é…ã€‚
* æœ‰å‡½æ•°ï¼Œæ³›å‹å‚æ•°å°±æ˜¯å‡½æ•°å…¥å‚ï¼Œå‡½æ•°å‚æ•°è¿˜æ”¯æŒé™å®šç±»å‹å’Œé»˜è®¤å€¼ã€‚ä½†å‡½æ•°ä¸æ˜¯ [First-Class-Function](https://en.wikipedia.org/wiki/First-class_function)ã€‚
* æ²¡æœ‰å¾ªç¯ï¼Œä½†å¯ä»¥é€šè¿‡å‡½æ•°çš„é€’å½’å®ç°ç­‰ä»·çš„æ•ˆæœã€‚

æ¥ç€æˆ‘ä»¬å›´ç»•ç”¨ TypeScript çš„ç±»å‹ç³»ç»Ÿå®ç° `Toc` è¯­è¨€çš„è§£é‡Šå™¨ï¼š
* é¦–å…ˆè®¨è®ºäº†ç”¨ TypeScript çš„ç±»å‹ç³»ç»Ÿæ€ä¹ˆå®ç°å››åˆ™ç®—æœ¯è¿ç®—å’Œæ¯”è¾ƒè¿ç®—ã€‚
* æ¥ç€å®ç°è§£é‡Šå™¨ï¼ŒæŒ‰ç…§è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€æ‰§è¡Œä¸‰ä¸ªé˜¶æ®µå±•å¼€ã€‚ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæ¯æ¬¡å…ˆç”¨ TypeScript æ¥å®ç°ï¼Œä¹‹åå†â€œç¿»è¯‘â€ä¸ºç±»å‹ç³»ç»Ÿçš„å®ç°ã€‚è¯­æ³•åˆ†æé˜¶æ®µï¼Œä»‹ç»äº†é€’å½’ä¸‹é™ç®—æ³•ã€‚æ‰§è¡Œé˜¶æ®µä»‹ç»äº†è®¿é—®è€…æ¨¡å¼ã€‚åœ¨å®ç°ä¸­ï¼Œæˆ‘ä»¬æŒæ¡äº†è¡¨è¾¾å¼å’Œè¯­å¥çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œä½œç”¨åŸŸå¦‚ä½•å®ç°ï¼Œå‡½æ•°ä»¥åŠé—­åŒ…çš„å®ç°æ–¹æ³•ã€‚é€šè¿‡ä¸¤ç§â€œè¯­è¨€â€çš„å¯¹æ¯”å®ç°ï¼Œä¹Ÿäº†è§£åˆ°å‹ç³»ç»Ÿä½œä¸ºè¯­è¨€æ¥ç”¨æ—¶çš„ä¸è¶³ã€‚

å¥½äº†ï¼Œä»¥ä¸Šå°±æ˜¯æˆ‘è¦è¯´çš„å…¨éƒ¨å†…å®¹ã€‚å¸Œæœ›ä½ èƒ½å–œæ¬¢ã€‚

> ç”±äºè‡ªèº«çš„è®¤çŸ¥æœ‰é™ï¼Œä»¥åŠæ—¶é—´ä¸Šçš„ä»“ä¿ƒï¼Œå…¶ä¸­è¿˜æœ‰å¾ˆå¤šçš„ä¸è¶³ï¼Œç”šè‡³é”™è¯¯ã€‚æ¬¢è¿å¤§å®¶è®¨è®ºæŒ‡æ­£ã€‚


## 4. å‚è€ƒ

1. [*Crafting Interpreters*](http://craftinginterpreters.com)
2. [TypeScript ç±»å‹ä½“æ“å¤©èŠ±æ¿ï¼Œç”¨ç±»å‹è¿ç®—å†™ä¸€ä¸ª Lisp è§£é‡Šå™¨](https://zhuanlan.zhihu.com/p/427309936?utm_campaign=shareopn&utm_medium=social&utm_oi=639544332005281792&utm_psn=1549037572080553985&utm_source=wechat_session)
3. [Implementing Arithmetic Within TypeScriptâ€™s Type System](https://itnext.io/implementing-arithmetic-within-typescripts-type-system-a1ef140a6f6f)
4. [How to Troubleshoot Types?](https://www.reddit.com/r/typescript/comments/sglwk6/how_to_troubleshoot_types/)
